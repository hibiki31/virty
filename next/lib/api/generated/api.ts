/* tslint:disable */
/* eslint-disable */
/**
 * VirtyAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthValidateResponse
 */
export interface AuthValidateResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthValidateResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthValidateResponse
     */
    'token_type': string;
    /**
     * 
     * @type {string}
     * @memberof AuthValidateResponse
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface CdromForUpdateDomain
 */
export interface CdromForUpdateDomain {
    /**
     * 
     * @type {string}
     * @memberof CdromForUpdateDomain
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof CdromForUpdateDomain
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface CloudInitInsert
 */
export interface CloudInitInsert {
    /**
     * 
     * @type {string}
     * @memberof CloudInitInsert
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof CloudInitInsert
     */
    'userData': string;
}
/**
 * 
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Domain
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof Domain
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof Domain
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'ownerProjectId'?: string;
    /**
     * 
     * @type {DomainProject}
     * @memberof Domain
     */
    'ownerProject'?: DomainProject;
    /**
     * 
     * @type {number}
     * @memberof Domain
     */
    'vncPort'?: number;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'vncPassword'?: string;
    /**
     * 
     * @type {Array<DomainDrive>}
     * @memberof Domain
     */
    'drives'?: Array<DomainDrive>;
    /**
     * 
     * @type {Array<DomainInterface>}
     * @memberof Domain
     */
    'interfaces'?: Array<DomainInterface>;
}
/**
 * 
 * @export
 * @interface DomainDetail
 */
export interface DomainDetail {
    /**
     * 
     * @type {string}
     * @memberof DomainDetail
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainDetail
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DomainDetail
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof DomainDetail
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof DomainDetail
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof DomainDetail
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainDetail
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof DomainDetail
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainDetail
     */
    'ownerProjectId'?: string;
    /**
     * 
     * @type {DomainProject}
     * @memberof DomainDetail
     */
    'ownerProject'?: DomainProject;
    /**
     * 
     * @type {number}
     * @memberof DomainDetail
     */
    'vncPort'?: number;
    /**
     * 
     * @type {string}
     * @memberof DomainDetail
     */
    'vncPassword'?: string;
    /**
     * 
     * @type {Array<DomainDrive>}
     * @memberof DomainDetail
     */
    'drives'?: Array<DomainDrive>;
    /**
     * 
     * @type {Array<DomainInterface>}
     * @memberof DomainDetail
     */
    'interfaces'?: Array<DomainInterface>;
    /**
     * 
     * @type {Node}
     * @memberof DomainDetail
     */
    'node': Node;
}
/**
 * 
 * @export
 * @interface DomainDrive
 */
export interface DomainDrive {
    /**
     * 
     * @type {string}
     * @memberof DomainDrive
     */
    'device'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainDrive
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainDrive
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainDrive
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface DomainForCreate
 */
export interface DomainForCreate {
    /**
     * 
     * @type {string}
     * @memberof DomainForCreate
     */
    'type': DomainForCreateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DomainForCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DomainForCreate
     */
    'nodeName': string;
    /**
     * 
     * @type {number}
     * @memberof DomainForCreate
     */
    'memoryMegaByte': number;
    /**
     * 
     * @type {number}
     * @memberof DomainForCreate
     */
    'cpu': number;
    /**
     * 
     * @type {Array<DomainForCreateDisk>}
     * @memberof DomainForCreate
     */
    'disks': Array<DomainForCreateDisk>;
    /**
     * 
     * @type {Array<DomainForCreateInterface>}
     * @memberof DomainForCreate
     */
    'interface': Array<DomainForCreateInterface>;
    /**
     * 
     * @type {CloudInitInsert}
     * @memberof DomainForCreate
     */
    'cloudInit'?: CloudInitInsert;
}

export const DomainForCreateTypeEnum = {
    Manual: 'manual',
    Project: 'project'
} as const;

export type DomainForCreateTypeEnum = typeof DomainForCreateTypeEnum[keyof typeof DomainForCreateTypeEnum];

/**
 * 
 * @export
 * @interface DomainForCreateDisk
 */
export interface DomainForCreateDisk {
    /**
     * 
     * @type {string}
     * @memberof DomainForCreateDisk
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof DomainForCreateDisk
     */
    'savePoolUuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainForCreateDisk
     */
    'originalPoolUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainForCreateDisk
     */
    'originalName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DomainForCreateDisk
     */
    'sizeGigaByte'?: number;
    /**
     * 
     * @type {string}
     * @memberof DomainForCreateDisk
     */
    'templateName'?: string;
}
/**
 * 
 * @export
 * @interface DomainForCreateInterface
 */
export interface DomainForCreateInterface {
    /**
     * 
     * @type {string}
     * @memberof DomainForCreateInterface
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof DomainForCreateInterface
     */
    'mac'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainForCreateInterface
     */
    'networkUuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainForCreateInterface
     */
    'port'?: string;
}
/**
 * 
 * @export
 * @interface DomainInterface
 */
export interface DomainInterface {
    /**
     * 
     * @type {string}
     * @memberof DomainInterface
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInterface
     */
    'mac'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInterface
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInterface
     */
    'bridge'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInterface
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInterface
     */
    'port'?: string;
}
/**
 * 
 * @export
 * @interface DomainPagenation
 */
export interface DomainPagenation {
    /**
     * 
     * @type {number}
     * @memberof DomainPagenation
     */
    'count': number;
    /**
     * 
     * @type {Array<Domain>}
     * @memberof DomainPagenation
     */
    'data': Array<Domain>;
}
/**
 * 
 * @export
 * @interface DomainProject
 */
export interface DomainProject {
    /**
     * 
     * @type {string}
     * @memberof DomainProject
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DomainProject
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Flavor
 */
export interface Flavor {
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    'os': string;
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    'manualUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof Flavor
     */
    'cloudInitReady': boolean;
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof Flavor
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface FlavorForCreate
 */
export interface FlavorForCreate {
    /**
     * 
     * @type {string}
     * @memberof FlavorForCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FlavorForCreate
     */
    'os': string;
    /**
     * 
     * @type {string}
     * @memberof FlavorForCreate
     */
    'manualUrl': string;
    /**
     * 
     * @type {string}
     * @memberof FlavorForCreate
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof FlavorForCreate
     */
    'cloudInitReady': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlavorForCreate
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'storageUuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'capacity': number;
    /**
     * 
     * @type {Storage}
     * @memberof Image
     */
    'storage': Storage;
    /**
     * 
     * @type {Flavor}
     * @memberof Image
     */
    'flavor'?: Flavor;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'allocation': number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'updateToken'?: string;
    /**
     * 
     * @type {ImageDomain}
     * @memberof Image
     */
    'domain'?: ImageDomain;
}
/**
 * 
 * @export
 * @interface ImageDomain
 */
export interface ImageDomain {
    /**
     * 
     * @type {string}
     * @memberof ImageDomain
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ImageDomain
     */
    'issuanceId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImageDomain
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ImageDomain
     */
    'uuid': string;
}
/**
 * 
 * @export
 * @interface ImageForUpdateImageFlavor
 */
export interface ImageForUpdateImageFlavor {
    /**
     * 
     * @type {string}
     * @memberof ImageForUpdateImageFlavor
     */
    'storageUuid': string;
    /**
     * 
     * @type {string}
     * @memberof ImageForUpdateImageFlavor
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof ImageForUpdateImageFlavor
     */
    'nodeName': string;
    /**
     * 
     * @type {number}
     * @memberof ImageForUpdateImageFlavor
     */
    'flavorId': number;
}
/**
 * 
 * @export
 * @interface ImageSCP
 */
export interface ImageSCP {
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'fromNodeName': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'toNodeName': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'fromFilePath': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'toFilePath': string;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof Network
     */
    'dhcp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Network
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'bridge'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Network
     */
    'autoStart'?: boolean;
    /**
     * 
     * @type {Array<NetworkPortgroup>}
     * @memberof Network
     */
    'portgroups': Array<NetworkPortgroup>;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'updateToken'?: string;
}
/**
 * 
 * @export
 * @interface NetworkForCreate
 */
export interface NetworkForCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkForCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkForCreate
     */
    'nodeName': string;
    /**
     * brdige or ovs
     * @type {string}
     * @memberof NetworkForCreate
     */
    'type': NetworkForCreateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NetworkForCreate
     */
    'bridgeDevice'?: string;
}

export const NetworkForCreateTypeEnum = {
    Bridge: 'bridge',
    Ovs: 'ovs'
} as const;

export type NetworkForCreateTypeEnum = typeof NetworkForCreateTypeEnum[keyof typeof NetworkForCreateTypeEnum];

/**
 * 
 * @export
 * @interface NetworkForNetworkPool
 */
export interface NetworkForNetworkPool {
    /**
     * 
     * @type {string}
     * @memberof NetworkForNetworkPool
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkForNetworkPool
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkForNetworkPool
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkForNetworkPool
     */
    'bridge': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkForNetworkPool
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface NetworkForUpdateDomain
 */
export interface NetworkForUpdateDomain {
    /**
     * 
     * @type {string}
     * @memberof NetworkForUpdateDomain
     */
    'mac': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkForUpdateDomain
     */
    'networkUuid': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkForUpdateDomain
     */
    'port'?: string;
}
/**
 * 
 * @export
 * @interface NetworkOVSForCreate
 */
export interface NetworkOVSForCreate {
    /**
     * 
     * @type {boolean}
     * @memberof NetworkOVSForCreate
     */
    'default': boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkOVSForCreate
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof NetworkOVSForCreate
     */
    'vlanId'?: number;
}
/**
 * 
 * @export
 * @interface NetworkPool
 */
export interface NetworkPool {
    /**
     * 
     * @type {number}
     * @memberof NetworkPool
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkPool
     */
    'name'?: string;
    /**
     * 
     * @type {Array<NetworkForNetworkPool>}
     * @memberof NetworkPool
     */
    'networks'?: Array<NetworkForNetworkPool>;
    /**
     * 
     * @type {Array<NetworkPoolPort>}
     * @memberof NetworkPool
     */
    'ports'?: Array<NetworkPoolPort>;
}
/**
 * 
 * @export
 * @interface NetworkPoolForCreate
 */
export interface NetworkPoolForCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkPoolForCreate
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface NetworkPoolForUpdate
 */
export interface NetworkPoolForUpdate {
    /**
     * 
     * @type {number}
     * @memberof NetworkPoolForUpdate
     */
    'poolId': number;
    /**
     * 
     * @type {string}
     * @memberof NetworkPoolForUpdate
     */
    'networkUuid': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkPoolForUpdate
     */
    'portName'?: string;
}
/**
 * 
 * @export
 * @interface NetworkPoolPort
 */
export interface NetworkPoolPort {
    /**
     * 
     * @type {string}
     * @memberof NetworkPoolPort
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof NetworkPoolPort
     */
    'vlanId'?: number;
    /**
     * 
     * @type {NetworkForNetworkPool}
     * @memberof NetworkPoolPort
     */
    'network': NetworkForNetworkPool;
}
/**
 * 
 * @export
 * @interface NetworkPortgroup
 */
export interface NetworkPortgroup {
    /**
     * 
     * @type {string}
     * @memberof NetworkPortgroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkPortgroup
     */
    'vlanId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkPortgroup
     */
    'isDefault': boolean;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'userName': string;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'port': number;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'memory': number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'cpuGen': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'osLike': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'osName': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'osVersion': string;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'qemuVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'libvirtVersion'?: string;
    /**
     * 
     * @type {Array<NodeRole>}
     * @memberof Node
     */
    'roles': Array<NodeRole>;
}
/**
 * 
 * @export
 * @interface NodeForCreate
 */
export interface NodeForCreate {
    /**
     * 
     * @type {string}
     * @memberof NodeForCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NodeForCreate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof NodeForCreate
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof NodeForCreate
     */
    'userName': string;
    /**
     * 
     * @type {number}
     * @memberof NodeForCreate
     */
    'port': number;
    /**
     * 
     * @type {boolean}
     * @memberof NodeForCreate
     */
    'libvirtRole': boolean;
}
/**
 * 
 * @export
 * @interface NodeRole
 */
export interface NodeRole {
    /**
     * 
     * @type {string}
     * @memberof NodeRole
     */
    'roleName': string;
    /**
     * 
     * @type {object}
     * @memberof NodeRole
     */
    'extraJson'?: object;
}
/**
 * 
 * @export
 * @interface NodeRoleForUpdate
 */
export interface NodeRoleForUpdate {
    /**
     * 
     * @type {string}
     * @memberof NodeRoleForUpdate
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof NodeRoleForUpdate
     */
    'roleName': string;
    /**
     * 
     * @type {object}
     * @memberof NodeRoleForUpdate
     */
    'extraJson'?: object;
}
/**
 * 
 * @export
 * @interface PowerStatusForUpdateDomain
 */
export interface PowerStatusForUpdateDomain {
    /**
     * 
     * @type {string}
     * @memberof PowerStatusForUpdateDomain
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'memoryG': number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'storageCapacityG': number;
    /**
     * 
     * @type {Array<UserBase>}
     * @memberof Project
     */
    'users': Array<UserBase>;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'usedMemoryG': number;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'usedCore': number;
    /**
     * 
     * @type {any}
     * @memberof Project
     */
    'networkPools'?: any;
    /**
     * 
     * @type {any}
     * @memberof Project
     */
    'storagePools'?: any;
}
/**
 * 
 * @export
 * @interface ProjectForCreate
 */
export interface ProjectForCreate {
    /**
     * 
     * @type {string}
     * @memberof ProjectForCreate
     */
    'projectName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectForCreate
     */
    'userIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ProjectForDelete
 */
export interface ProjectForDelete {
    /**
     * 
     * @type {string}
     * @memberof ProjectForDelete
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ProjectForUpdate
 */
export interface ProjectForUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProjectForUpdate
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectForUpdate
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface SSHKeyPair
 */
export interface SSHKeyPair {
    /**
     * 
     * @type {string}
     * @memberof SSHKeyPair
     */
    'privateKey': string;
    /**
     * 
     * @type {string}
     * @memberof SSHKeyPair
     */
    'publicKey': string;
}
/**
 * 
 * @export
 * @interface SetupRequest
 */
export interface SetupRequest {
    /**
     * 
     * @type {string}
     * @memberof SetupRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof SetupRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Storage
 */
export interface Storage {
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'uuid': string;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    'status': number;
    /**
     * 
     * @type {boolean}
     * @memberof Storage
     */
    'active': boolean;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    'available'?: number;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    'capacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'nodeName': string;
    /**
     * 
     * @type {Node}
     * @memberof Storage
     */
    'node': Node;
    /**
     * 
     * @type {boolean}
     * @memberof Storage
     */
    'autoStart': boolean;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'path'?: string;
    /**
     * 
     * @type {StorageMetadata}
     * @memberof Storage
     */
    'metaData'?: StorageMetadata;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'updateToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    'allocationCommit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    'capacityCommit'?: number;
}
/**
 * 
 * @export
 * @interface StorageContainerForStoragePool
 */
export interface StorageContainerForStoragePool {
    /**
     * 
     * @type {StorageForStorageContainer}
     * @memberof StorageContainerForStoragePool
     */
    'storage': StorageForStorageContainer;
}
/**
 * 
 * @export
 * @interface StorageForCreate
 */
export interface StorageForCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageForCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageForCreate
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof StorageForCreate
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface StorageForStorageContainer
 */
export interface StorageForStorageContainer {
    /**
     * 
     * @type {string}
     * @memberof StorageForStorageContainer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageForStorageContainer
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof StorageForStorageContainer
     */
    'nodeName': string;
}
/**
 * 
 * @export
 * @interface StorageMetadata
 */
export interface StorageMetadata {
    /**
     * 
     * @type {string}
     * @memberof StorageMetadata
     */
    'rool'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadata
     */
    'protocol'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadata
     */
    'deviceType'?: string;
}
/**
 * 
 * @export
 * @interface StorageMetadataForUpdate
 */
export interface StorageMetadataForUpdate {
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataForUpdate
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataForUpdate
     */
    'rool': string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataForUpdate
     */
    'protocol': string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataForUpdate
     */
    'deviceType': string;
}
/**
 * 
 * @export
 * @interface StoragePool
 */
export interface StoragePool {
    /**
     * 
     * @type {number}
     * @memberof StoragePool
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StoragePool
     */
    'name': string;
    /**
     * 
     * @type {Array<StorageContainerForStoragePool>}
     * @memberof StoragePool
     */
    'storages': Array<StorageContainerForStoragePool>;
}
/**
 * 
 * @export
 * @interface StoragePoolForCreate
 */
export interface StoragePoolForCreate {
    /**
     * 
     * @type {string}
     * @memberof StoragePoolForCreate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StoragePoolForCreate
     */
    'storageUuids': Array<string>;
}
/**
 * 
 * @export
 * @interface StoragePoolForUpdate
 */
export interface StoragePoolForUpdate {
    /**
     * 
     * @type {string}
     * @memberof StoragePoolForUpdate
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StoragePoolForUpdate
     */
    'storageUuids': Array<string>;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'postTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'runTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'resource'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'method'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'dependenceUuid'?: string;
    /**
     * 
     * @type {object}
     * @memberof Task
     */
    'request'?: object;
    /**
     * 
     * @type {object}
     * @memberof Task
     */
    'result'?: object;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'log'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'uuid'?: string;
}
/**
 * 
 * @export
 * @interface TaskIncomplete
 */
export interface TaskIncomplete {
    /**
     * 
     * @type {string}
     * @memberof TaskIncomplete
     */
    'hash': string;
    /**
     * 
     * @type {number}
     * @memberof TaskIncomplete
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskIncomplete
     */
    'uuids': Array<string>;
}
/**
 * 
 * @export
 * @interface TaskPagesnation
 */
export interface TaskPagesnation {
    /**
     * 
     * @type {number}
     * @memberof TaskPagesnation
     */
    'count': number;
    /**
     * 
     * @type {Array<Task>}
     * @memberof TaskPagesnation
     */
    'data': Array<Task>;
}
/**
 * 
 * @export
 * @interface TokenData
 */
export interface TokenData {
    /**
     * 
     * @type {string}
     * @memberof TokenData
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TokenData
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TokenData
     */
    'role'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TokenRFC6749Response
 */
export interface TokenRFC6749Response {
    /**
     * 
     * @type {string}
     * @memberof TokenRFC6749Response
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRFC6749Response
     */
    'token_type': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {Array<UserScope>}
     * @memberof User
     */
    'scopes': Array<UserScope>;
    /**
     * 
     * @type {Array<UserProject>}
     * @memberof User
     */
    'projects': Array<UserProject>;
}
/**
 * 
 * @export
 * @interface UserBase
 */
export interface UserBase {
    /**
     * 
     * @type {string}
     * @memberof UserBase
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserForCreate
 */
export interface UserForCreate {
    /**
     * 
     * @type {string}
     * @memberof UserForCreate
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserForCreate
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserProject
 */
export interface UserProject {
    /**
     * 
     * @type {string}
     * @memberof UserProject
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UserScope
 */
export interface UserScope {
    /**
     * 
     * @type {string}
     * @memberof UserScope
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    'loc': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * 
     * @type {boolean}
     * @memberof Version
     */
    'initialized': boolean;
    /**
     * 
     * @type {string}
     * @memberof Version
     */
    'version': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('login', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('login', 'password', password)
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Api Auth Setup
         * @param {SetupRequest} setupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup: async (setupRequest: SetupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setupRequest' is not null or undefined
            assertParamExists('setup', 'setupRequest', setupRequest)
            const localVarPath = `/api/auth/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRFC6749Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Api Auth Setup
         * @param {SetupRequest} setupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setup(setupRequest: SetupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setup(setupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthValidateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<TokenRFC6749Response> {
            return localVarFp.login(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Api Auth Setup
         * @param {SetupRequest} setupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setup(setupRequest: SetupRequest, options?: any): AxiosPromise<any> {
            return localVarFp.setup(setupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken(options?: any): AxiosPromise<AuthValidateResponse> {
            return localVarFp.validateToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Login For Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Api Auth Setup
     * @param {SetupRequest} setupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public setup(setupRequest: SetupRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).setup(setupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Auth Validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public validateToken(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).validateToken(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FlavorsApi - axios parameter creator
 * @export
 */
export const FlavorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post Api Flavors
         * @param {FlavorForCreate} flavorForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlavor: async (flavorForCreate: FlavorForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorForCreate' is not null or undefined
            assertParamExists('createFlavor', 'flavorForCreate', flavorForCreate)
            const localVarPath = `/api/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlavors: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlavorsApi - functional programming interface
 * @export
 */
export const FlavorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlavorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post Api Flavors
         * @param {FlavorForCreate} flavorForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlavor(flavorForCreate: FlavorForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlavor(flavorForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlavors(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Flavor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlavors(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FlavorsApi - factory interface
 * @export
 */
export const FlavorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlavorsApiFp(configuration)
    return {
        /**
         * 
         * @summary Post Api Flavors
         * @param {FlavorForCreate} flavorForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlavor(flavorForCreate: FlavorForCreate, options?: any): AxiosPromise<any> {
            return localVarFp.createFlavor(flavorForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlavors(options?: any): AxiosPromise<Array<Flavor>> {
            return localVarFp.getFlavors(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlavorsApi - object-oriented interface
 * @export
 * @class FlavorsApi
 * @extends {BaseAPI}
 */
export class FlavorsApi extends BaseAPI {
    /**
     * 
     * @summary Post Api Flavors
     * @param {FlavorForCreate} flavorForCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public createFlavor(flavorForCreate: FlavorForCreate, options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).createFlavor(flavorForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Flavors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public getFlavors(options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).getFlavors(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Images
         * @param {string} [nodeName] 
         * @param {string} [poolUuid] 
         * @param {string} [name] 
         * @param {string} [rool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImages: async (nodeName?: string, poolUuid?: string, name?: string, rool?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (nodeName !== undefined) {
                localVarQueryParameter['node_name'] = nodeName;
            }

            if (poolUuid !== undefined) {
                localVarQueryParameter['pool_uuid'] = poolUuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (rool !== undefined) {
                localVarQueryParameter['rool'] = rool;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Images Scp
         * @param {ImageSCP} [imageSCP] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scpImage: async (imageSCP?: ImageSCP, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images/scp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageSCP, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Images
         * @param {ImageForUpdateImageFlavor} imageForUpdateImageFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageFlavor: async (imageForUpdateImageFlavor: ImageForUpdateImageFlavor, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageForUpdateImageFlavor' is not null or undefined
            assertParamExists('updateImageFlavor', 'imageForUpdateImageFlavor', imageForUpdateImageFlavor)
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageForUpdateImageFlavor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Images
         * @param {string} [nodeName] 
         * @param {string} [poolUuid] 
         * @param {string} [name] 
         * @param {string} [rool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImages(nodeName?: string, poolUuid?: string, name?: string, rool?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImages(nodeName, poolUuid, name, rool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Images Scp
         * @param {ImageSCP} [imageSCP] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scpImage(imageSCP?: ImageSCP, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scpImage(imageSCP, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Images
         * @param {ImageForUpdateImageFlavor} imageForUpdateImageFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImageFlavor(imageForUpdateImageFlavor: ImageForUpdateImageFlavor, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImageFlavor(imageForUpdateImageFlavor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Images
         * @param {string} [nodeName] 
         * @param {string} [poolUuid] 
         * @param {string} [name] 
         * @param {string} [rool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImages(nodeName?: string, poolUuid?: string, name?: string, rool?: string, options?: any): AxiosPromise<Array<Image>> {
            return localVarFp.getImages(nodeName, poolUuid, name, rool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Images Scp
         * @param {ImageSCP} [imageSCP] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scpImage(imageSCP?: ImageSCP, options?: any): AxiosPromise<any> {
            return localVarFp.scpImage(imageSCP, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Images
         * @param {ImageForUpdateImageFlavor} imageForUpdateImageFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageFlavor(imageForUpdateImageFlavor: ImageForUpdateImageFlavor, options?: any): AxiosPromise<any> {
            return localVarFp.updateImageFlavor(imageForUpdateImageFlavor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Images
     * @param {string} [nodeName] 
     * @param {string} [poolUuid] 
     * @param {string} [name] 
     * @param {string} [rool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public getImages(nodeName?: string, poolUuid?: string, name?: string, rool?: string, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).getImages(nodeName, poolUuid, name, rool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Images Scp
     * @param {ImageSCP} [imageSCP] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public scpImage(imageSCP?: ImageSCP, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).scpImage(imageSCP, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Images
     * @param {ImageForUpdateImageFlavor} imageForUpdateImageFlavor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public updateImageFlavor(imageForUpdateImageFlavor: ImageForUpdateImageFlavor, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).updateImageFlavor(imageForUpdateImageFlavor, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImagesTaskApi - axios parameter creator
 * @export
 */
export const ImagesTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Put Api Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshImages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesTaskApi - functional programming interface
 * @export
 */
export const ImagesTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Put Api Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshImages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshImages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImagesTaskApi - factory interface
 * @export
 */
export const ImagesTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesTaskApiFp(configuration)
    return {
        /**
         * 
         * @summary Put Api Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshImages(options?: any): AxiosPromise<any> {
            return localVarFp.refreshImages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesTaskApi - object-oriented interface
 * @export
 * @class ImagesTaskApi
 * @extends {BaseAPI}
 */
export class ImagesTaskApi extends BaseAPI {
    /**
     * 
     * @summary Put Api Images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesTaskApi
     */
    public refreshImages(options?: AxiosRequestConfig) {
        return ImagesTaskApiFp(this.configuration).refreshImages(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exporter Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Exporter Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Exporter Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any): AxiosPromise<string> {
            return localVarFp.getMetrics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Exporter Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MixinApi - axios parameter creator
 * @export
 */
export const MixinApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 初期化済みか判定用
         * @summary Get Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MixinApi - functional programming interface
 * @export
 */
export const MixinApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MixinApiAxiosParamCreator(configuration)
    return {
        /**
         * 初期化済みか判定用
         * @summary Get Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MixinApi - factory interface
 * @export
 */
export const MixinApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MixinApiFp(configuration)
    return {
        /**
         * 初期化済みか判定用
         * @summary Get Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<Version> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MixinApi - object-oriented interface
 * @export
 * @class MixinApi
 * @extends {BaseAPI}
 */
export class MixinApi extends BaseAPI {
    /**
     * 初期化済みか判定用
     * @summary Get Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MixinApi
     */
    public getVersion(options?: AxiosRequestConfig) {
        return MixinApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworksApi - axios parameter creator
 * @export
 */
export const NetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post Api Networks Pools
         * @param {NetworkPoolForCreate} networkPoolForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetworkPool: async (networkPoolForCreate: NetworkPoolForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkPoolForCreate' is not null or undefined
            assertParamExists('createNetworkPool', 'networkPoolForCreate', networkPoolForCreate)
            const localVarPath = `/api/networks/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkPoolForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Pools Uuid
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetworkPool: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNetworkPool', 'id', id)
            const localVarPath = `/api/networks/pools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Networks Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetwork: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getNetwork', 'uuid', uuid)
            const localVarPath = `/api/networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Networks Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkPools: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Networks Pools
         * @param {NetworkPoolForUpdate} networkPoolForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNetworkPool: async (networkPoolForUpdate: NetworkPoolForUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkPoolForUpdate' is not null or undefined
            assertParamExists('updateNetworkPool', 'networkPoolForUpdate', networkPoolForUpdate)
            const localVarPath = `/api/networks/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkPoolForUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworksApi - functional programming interface
 * @export
 */
export const NetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post Api Networks Pools
         * @param {NetworkPoolForCreate} networkPoolForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNetworkPool(networkPoolForCreate: NetworkPoolForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNetworkPool(networkPoolForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Pools Uuid
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNetworkPool(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNetworkPool(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Networks Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetwork(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetwork(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Networks Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkPools(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkPool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkPools(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Network>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Networks Pools
         * @param {NetworkPoolForUpdate} networkPoolForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNetworkPool(networkPoolForUpdate: NetworkPoolForUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNetworkPool(networkPoolForUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworksApi - factory interface
 * @export
 */
export const NetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary Post Api Networks Pools
         * @param {NetworkPoolForCreate} networkPoolForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetworkPool(networkPoolForCreate: NetworkPoolForCreate, options?: any): AxiosPromise<any> {
            return localVarFp.createNetworkPool(networkPoolForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Pools Uuid
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetworkPool(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteNetworkPool(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Networks Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetwork(uuid: string, options?: any): AxiosPromise<Network> {
            return localVarFp.getNetwork(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Networks Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkPools(options?: any): AxiosPromise<Array<NetworkPool>> {
            return localVarFp.getNetworkPools(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworks(options?: any): AxiosPromise<Array<Network>> {
            return localVarFp.getNetworks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Networks Pools
         * @param {NetworkPoolForUpdate} networkPoolForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNetworkPool(networkPoolForUpdate: NetworkPoolForUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.updateNetworkPool(networkPoolForUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworksApi - object-oriented interface
 * @export
 * @class NetworksApi
 * @extends {BaseAPI}
 */
export class NetworksApi extends BaseAPI {
    /**
     * 
     * @summary Post Api Networks Pools
     * @param {NetworkPoolForCreate} networkPoolForCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public createNetworkPool(networkPoolForCreate: NetworkPoolForCreate, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).createNetworkPool(networkPoolForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Pools Uuid
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public deleteNetworkPool(id: number, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).deleteNetworkPool(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Networks Uuid
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public getNetwork(uuid: string, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).getNetwork(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Networks Pools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public getNetworkPools(options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).getNetworkPools(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public getNetworks(options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).getNetworks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Networks Pools
     * @param {NetworkPoolForUpdate} networkPoolForUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public updateNetworkPool(networkPoolForUpdate: NetworkPoolForUpdate, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).updateNetworkPool(networkPoolForUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworksTaskApi - axios parameter creator
 * @export
 */
export const NetworksTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkForCreate} [networkForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetwork: async (networkForCreate?: NetworkForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Uuid Ovs
         * @param {string} uuid 
         * @param {NetworkOVSForCreate} [networkOVSForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetworkOvs: async (uuid: string, networkOVSForCreate?: NetworkOVSForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('createNetworkOvs', 'uuid', uuid)
            const localVarPath = `/api/tasks/networks/{uuid}/ovs`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkOVSForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Storage
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetwork: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteNetwork', 'uuid', uuid)
            const localVarPath = `/api/tasks/networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {string} uuid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetworkOvs: async (uuid: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteNetworkOvs', 'uuid', uuid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteNetworkOvs', 'name', name)
            const localVarPath = `/api/tasks/networks/{uuid}/ovs/{name}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNetworks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworksTaskApi - functional programming interface
 * @export
 */
export const NetworksTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworksTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkForCreate} [networkForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNetwork(networkForCreate?: NetworkForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNetwork(networkForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Uuid Ovs
         * @param {string} uuid 
         * @param {NetworkOVSForCreate} [networkOVSForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNetworkOvs(uuid: string, networkOVSForCreate?: NetworkOVSForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNetworkOvs(uuid, networkOVSForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Api Storage
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNetwork(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNetwork(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {string} uuid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNetworkOvs(uuid: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNetworkOvs(uuid, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshNetworks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshNetworks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworksTaskApi - factory interface
 * @export
 */
export const NetworksTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworksTaskApiFp(configuration)
    return {
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkForCreate} [networkForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetwork(networkForCreate?: NetworkForCreate, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.createNetwork(networkForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Uuid Ovs
         * @param {string} uuid 
         * @param {NetworkOVSForCreate} [networkOVSForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetworkOvs(uuid: string, networkOVSForCreate?: NetworkOVSForCreate, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.createNetworkOvs(uuid, networkOVSForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Storage
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetwork(uuid: string, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.deleteNetwork(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {string} uuid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetworkOvs(uuid: string, name: string, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.deleteNetworkOvs(uuid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNetworks(options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.refreshNetworks(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworksTaskApi - object-oriented interface
 * @export
 * @class NetworksTaskApi
 * @extends {BaseAPI}
 */
export class NetworksTaskApi extends BaseAPI {
    /**
     * 
     * @summary Post Api Storage
     * @param {NetworkForCreate} [networkForCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public createNetwork(networkForCreate?: NetworkForCreate, options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).createNetwork(networkForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Uuid Ovs
     * @param {string} uuid 
     * @param {NetworkOVSForCreate} [networkOVSForCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public createNetworkOvs(uuid: string, networkOVSForCreate?: NetworkOVSForCreate, options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).createNetworkOvs(uuid, networkOVSForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Storage
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public deleteNetwork(uuid: string, options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).deleteNetwork(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Networks Uuid Ovs
     * @param {string} uuid 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public deleteNetworkOvs(uuid: string, name: string, options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).deleteNetworkOvs(uuid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public refreshNetworks(options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).refreshNetworks(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Node
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getNode', 'name', name)
            const localVarPath = `/api/nodes/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Node Name Facts
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeFacts: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getNodeFacts', 'name', name)
            const localVarPath = `/api/nodes/{name}/facts`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshKeyPair: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Ssh Key Pair
         * @param {SSHKeyPair} sSHKeyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSshKeyPair: async (sSHKeyPair: SSHKeyPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sSHKeyPair' is not null or undefined
            assertParamExists('updateSshKeyPair', 'sSHKeyPair', sSHKeyPair)
            const localVarPath = `/api/nodes/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sSHKeyPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Node
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNode(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Node>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNode(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Node Name Facts
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeFacts(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeFacts(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Node>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSshKeyPair(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSHKeyPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSshKeyPair(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Ssh Key Pair
         * @param {SSHKeyPair} sSHKeyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSshKeyPair(sSHKeyPair: SSHKeyPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSshKeyPair(sSHKeyPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Node
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(name: string, options?: any): AxiosPromise<Node> {
            return localVarFp.getNode(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Node Name Facts
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeFacts(name: string, options?: any): AxiosPromise<any> {
            return localVarFp.getNodeFacts(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options?: any): AxiosPromise<Array<Node>> {
            return localVarFp.getNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshKeyPair(options?: any): AxiosPromise<SSHKeyPair> {
            return localVarFp.getSshKeyPair(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Ssh Key Pair
         * @param {SSHKeyPair} sSHKeyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSshKeyPair(sSHKeyPair: SSHKeyPair, options?: any): AxiosPromise<any> {
            return localVarFp.updateSshKeyPair(sSHKeyPair, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Node
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNode(name: string, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getNode(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Node Name Facts
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNodeFacts(name: string, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getNodeFacts(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNodes(options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getNodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Ssh Key Pair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getSshKeyPair(options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getSshKeyPair(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Ssh Key Pair
     * @param {SSHKeyPair} sSHKeyPair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateSshKeyPair(sSHKeyPair: SSHKeyPair, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).updateSshKeyPair(sSHKeyPair, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesTaskApi - axios parameter creator
 * @export
 */
export const NodesTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post Tasks Nodes
         * @param {NodeForCreate} [nodeForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode: async (nodeForCreate?: NodeForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Tasks Nodes Name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNode: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteNode', 'name', name)
            const localVarPath = `/api/tasks/nodes/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Node Role
         * @param {NodeRoleForUpdate} nodeRoleForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeRole: async (nodeRoleForUpdate: NodeRoleForUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeRoleForUpdate' is not null or undefined
            assertParamExists('updateNodeRole', 'nodeRoleForUpdate', nodeRoleForUpdate)
            const localVarPath = `/api/tasks/nodes/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeRoleForUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesTaskApi - functional programming interface
 * @export
 */
export const NodesTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post Tasks Nodes
         * @param {NodeForCreate} [nodeForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNode(nodeForCreate?: NodeForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNode(nodeForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Tasks Nodes Name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNode(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNode(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Node Role
         * @param {NodeRoleForUpdate} nodeRoleForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNodeRole(nodeRoleForUpdate: NodeRoleForUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNodeRole(nodeRoleForUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesTaskApi - factory interface
 * @export
 */
export const NodesTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesTaskApiFp(configuration)
    return {
        /**
         * 
         * @summary Post Tasks Nodes
         * @param {NodeForCreate} [nodeForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(nodeForCreate?: NodeForCreate, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.createNode(nodeForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Tasks Nodes Name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNode(name: string, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.deleteNode(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Node Role
         * @param {NodeRoleForUpdate} nodeRoleForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodeRole(nodeRoleForUpdate: NodeRoleForUpdate, options?: any): AxiosPromise<Task> {
            return localVarFp.updateNodeRole(nodeRoleForUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesTaskApi - object-oriented interface
 * @export
 * @class NodesTaskApi
 * @extends {BaseAPI}
 */
export class NodesTaskApi extends BaseAPI {
    /**
     * 
     * @summary Post Tasks Nodes
     * @param {NodeForCreate} [nodeForCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesTaskApi
     */
    public createNode(nodeForCreate?: NodeForCreate, options?: AxiosRequestConfig) {
        return NodesTaskApiFp(this.configuration).createNode(nodeForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Tasks Nodes Name
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesTaskApi
     */
    public deleteNode(name: string, options?: AxiosRequestConfig) {
        return NodesTaskApiFp(this.configuration).deleteNode(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Node Role
     * @param {NodeRoleForUpdate} nodeRoleForUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesTaskApi
     */
    public updateNodeRole(nodeRoleForUpdate: NodeRoleForUpdate, options?: AxiosRequestConfig) {
        return NodesTaskApiFp(this.configuration).updateNodeRole(nodeRoleForUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post Api Projects
         * @param {ProjectForCreate} projectForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (projectForCreate: ProjectForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectForCreate' is not null or undefined
            assertParamExists('createProject', 'projectForCreate', projectForCreate)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Projects
         * @param {ProjectForDelete} projectForDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectForDelete: ProjectForDelete, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectForDelete' is not null or undefined
            assertParamExists('deleteProject', 'projectForDelete', projectForDelete)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectForDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Projects
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Projects
         * @param {ProjectForUpdate} projectForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectForUpdate: ProjectForUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectForUpdate' is not null or undefined
            assertParamExists('updateProject', 'projectForUpdate', projectForUpdate)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectForUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post Api Projects
         * @param {ProjectForCreate} projectForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(projectForCreate: ProjectForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(projectForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Api Projects
         * @param {ProjectForDelete} projectForDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectForDelete: ProjectForDelete, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectForDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Projects
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Projects
         * @param {ProjectForUpdate} projectForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectForUpdate: ProjectForUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectForUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Post Api Projects
         * @param {ProjectForCreate} projectForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(projectForCreate: ProjectForCreate, options?: any): AxiosPromise<any> {
            return localVarFp.createProject(projectForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Projects
         * @param {ProjectForDelete} projectForDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectForDelete: ProjectForDelete, options?: any): AxiosPromise<any> {
            return localVarFp.deleteProject(projectForDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Projects
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(admin?: boolean, options?: any): AxiosPromise<Array<Project>> {
            return localVarFp.getProjects(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Projects
         * @param {ProjectForUpdate} projectForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectForUpdate: ProjectForUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.updateProject(projectForUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Post Api Projects
     * @param {ProjectForCreate} projectForCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(projectForCreate: ProjectForCreate, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(projectForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Projects
     * @param {ProjectForDelete} projectForDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectForDelete: ProjectForDelete, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProject(projectForDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Projects
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjects(admin?: boolean, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProjects(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Projects
     * @param {ProjectForUpdate} projectForUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(projectForUpdate: ProjectForUpdate, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProject(projectForUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoragesApi - axios parameter creator
 * @export
 */
export const StoragesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {StoragePoolForCreate} storagePoolForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStoragePool: async (storagePoolForCreate: StoragePoolForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storagePoolForCreate' is not null or undefined
            assertParamExists('createStoragePool', 'storagePoolForCreate', storagePoolForCreate)
            const localVarPath = `/api/storages/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storagePoolForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Storages Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getStorage', 'uuid', uuid)
            const localVarPath = `/api/storages/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Storages Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoragePools: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Storages
         * @param {string} [name] 
         * @param {string} [nodeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorages: async (name?: string, nodeName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nodeName !== undefined) {
                localVarQueryParameter['nodeName'] = nodeName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageMetadataForUpdate} [storageMetadataForUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageMetadata: async (storageMetadataForUpdate?: StorageMetadataForUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageMetadataForUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {StoragePoolForUpdate} storagePoolForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStoragePool: async (storagePoolForUpdate: StoragePoolForUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storagePoolForUpdate' is not null or undefined
            assertParamExists('updateStoragePool', 'storagePoolForUpdate', storagePoolForUpdate)
            const localVarPath = `/api/storages/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storagePoolForUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoragesApi - functional programming interface
 * @export
 */
export const StoragesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoragesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {StoragePoolForCreate} storagePoolForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStoragePool(storagePoolForCreate: StoragePoolForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStoragePool(storagePoolForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Storages Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorage(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorage(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Storages Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStoragePools(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StoragePool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStoragePools(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Storages
         * @param {string} [name] 
         * @param {string} [nodeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorages(name?: string, nodeName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Storage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorages(name, nodeName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageMetadataForUpdate} [storageMetadataForUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStorageMetadata(storageMetadataForUpdate?: StorageMetadataForUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStorageMetadata(storageMetadataForUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {StoragePoolForUpdate} storagePoolForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStoragePool(storagePoolForUpdate: StoragePoolForUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStoragePool(storagePoolForUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoragesApi - factory interface
 * @export
 */
export const StoragesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoragesApiFp(configuration)
    return {
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {StoragePoolForCreate} storagePoolForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStoragePool(storagePoolForCreate: StoragePoolForCreate, options?: any): AxiosPromise<any> {
            return localVarFp.createStoragePool(storagePoolForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Storages Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(uuid: string, options?: any): AxiosPromise<Storage> {
            return localVarFp.getStorage(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Storages Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoragePools(options?: any): AxiosPromise<Array<StoragePool>> {
            return localVarFp.getStoragePools(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Storages
         * @param {string} [name] 
         * @param {string} [nodeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorages(name?: string, nodeName?: string, options?: any): AxiosPromise<Array<Storage>> {
            return localVarFp.getStorages(name, nodeName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageMetadataForUpdate} [storageMetadataForUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageMetadata(storageMetadataForUpdate?: StorageMetadataForUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.updateStorageMetadata(storageMetadataForUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {StoragePoolForUpdate} storagePoolForUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStoragePool(storagePoolForUpdate: StoragePoolForUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.updateStoragePool(storagePoolForUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoragesApi - object-oriented interface
 * @export
 * @class StoragesApi
 * @extends {BaseAPI}
 */
export class StoragesApi extends BaseAPI {
    /**
     * 
     * @summary Post Api Storages Pools
     * @param {StoragePoolForCreate} storagePoolForCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public createStoragePool(storagePoolForCreate: StoragePoolForCreate, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).createStoragePool(storagePoolForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Storages Uuid
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public getStorage(uuid: string, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).getStorage(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Storages Pools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public getStoragePools(options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).getStoragePools(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Storages
     * @param {string} [name] 
     * @param {string} [nodeName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public getStorages(name?: string, nodeName?: string, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).getStorages(name, nodeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storage
     * @param {StorageMetadataForUpdate} [storageMetadataForUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public updateStorageMetadata(storageMetadataForUpdate?: StorageMetadataForUpdate, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).updateStorageMetadata(storageMetadataForUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storages Pools
     * @param {StoragePoolForUpdate} storagePoolForUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public updateStoragePool(storagePoolForUpdate: StoragePoolForUpdate, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).updateStoragePool(storagePoolForUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoragesTaskApi - axios parameter creator
 * @export
 */
export const StoragesTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageForCreate} [storageForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage: async (storageForCreate?: StorageForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Storages
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStorage: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteStorage', 'uuid', uuid)
            const localVarPath = `/api/tasks/storages/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoragesTaskApi - functional programming interface
 * @export
 */
export const StoragesTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoragesTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageForCreate} [storageForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStorage(storageForCreate?: StorageForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStorage(storageForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Api Storages
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStorage(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStorage(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoragesTaskApi - factory interface
 * @export
 */
export const StoragesTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoragesTaskApiFp(configuration)
    return {
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageForCreate} [storageForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(storageForCreate?: StorageForCreate, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.createStorage(storageForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Storages
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStorage(uuid: string, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.deleteStorage(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoragesTaskApi - object-oriented interface
 * @export
 * @class StoragesTaskApi
 * @extends {BaseAPI}
 */
export class StoragesTaskApi extends BaseAPI {
    /**
     * 
     * @summary Post Api Storage
     * @param {StorageForCreate} [storageForCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesTaskApi
     */
    public createStorage(storageForCreate?: StorageForCreate, options?: AxiosRequestConfig) {
        return StoragesTaskApiFp(this.configuration).createStorage(storageForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Storages
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesTaskApi
     */
    public deleteStorage(uuid: string, options?: AxiosRequestConfig) {
        return StoragesTaskApiFp(this.configuration).deleteStorage(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tasks Incomplete
         * @param {string} [hash] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncompleteTasks: async (hash?: string, admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/incomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tasks
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getTask', 'uuid', uuid)
            const localVarPath = `/api/tasks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tasks
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [resource] 
         * @param {string} [object] 
         * @param {string} [method] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (admin?: boolean, limit?: number, page?: number, resource?: string, object?: string, method?: string, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTasks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTasks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tasks Incomplete
         * @param {string} [hash] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncompleteTasks(hash?: string, admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskIncomplete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncompleteTasks(hash, admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tasks
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tasks
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [resource] 
         * @param {string} [object] 
         * @param {string} [method] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(admin?: boolean, limit?: number, page?: number, resource?: string, object?: string, method?: string, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskPagesnation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(admin, limit, page, resource, object, method, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasks(options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.deleteTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tasks Incomplete
         * @param {string} [hash] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncompleteTasks(hash?: string, admin?: boolean, options?: any): AxiosPromise<TaskIncomplete> {
            return localVarFp.getIncompleteTasks(hash, admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tasks
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(uuid: string, options?: any): AxiosPromise<Task> {
            return localVarFp.getTask(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tasks
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [resource] 
         * @param {string} [object] 
         * @param {string} [method] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(admin?: boolean, limit?: number, page?: number, resource?: string, object?: string, method?: string, status?: string, options?: any): AxiosPromise<TaskPagesnation> {
            return localVarFp.getTasks(admin, limit, page, resource, object, method, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary Delete Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTasks(options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).deleteTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tasks Incomplete
     * @param {string} [hash] 
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getIncompleteTasks(hash?: string, admin?: boolean, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getIncompleteTasks(hash, admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tasks
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTask(uuid: string, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTask(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tasks
     * @param {boolean} [admin] 
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {string} [resource] 
     * @param {string} [object] 
     * @param {string} [method] 
     * @param {string} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasks(admin?: boolean, limit?: number, page?: number, resource?: string, object?: string, method?: string, status?: string, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTasks(admin, limit, page, resource, object, method, status, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post Api Users
         * @param {UserForCreate} userForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userForCreate: UserForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userForCreate' is not null or undefined
            assertParamExists('createUser', 'userForCreate', userForCreate)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post Api Users
         * @param {UserForCreate} userForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userForCreate: UserForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Post Api Users
         * @param {UserForCreate} userForCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userForCreate: UserForCreate, options?: any): AxiosPromise<any> {
            return localVarFp.createUser(userForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<TokenData> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Post Api Users
     * @param {UserForCreate} userForCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(userForCreate: UserForCreate, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(userForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Users Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VmsApi - axios parameter creator
 * @export
 */
export const VmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Domain Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getVm', 'uuid', uuid)
            const localVarPath = `/api/vms/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [nameLike] 
         * @param {string} [nodeNameLike] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms: async (admin?: boolean, limit?: number, page?: number, nameLike?: string, nodeNameLike?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['name_like'] = nameLike;
            }

            if (nodeNameLike !== undefined) {
                localVarQueryParameter['node_name_like'] = nodeNameLike;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVncAddress: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getVncAddress', 'token', token)
            const localVarPath = `/api/vms/vnc/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VmsApi - functional programming interface
 * @export
 */
export const VmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Domain Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVm(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVm(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [nameLike] 
         * @param {string} [nodeNameLike] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVms(admin?: boolean, limit?: number, page?: number, nameLike?: string, nodeNameLike?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainPagenation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVms(admin, limit, page, nameLike, nodeNameLike, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVncAddress(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVncAddress(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VmsApi - factory interface
 * @export
 */
export const VmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VmsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Domain Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVm(uuid: string, options?: any): AxiosPromise<DomainDetail> {
            return localVarFp.getVm(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [nameLike] 
         * @param {string} [nodeNameLike] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVms(admin?: boolean, limit?: number, page?: number, nameLike?: string, nodeNameLike?: string, options?: any): AxiosPromise<DomainPagenation> {
            return localVarFp.getVms(admin, limit, page, nameLike, nodeNameLike, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVncAddress(token: string, options?: any): AxiosPromise<any> {
            return localVarFp.getVncAddress(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VmsApi - object-oriented interface
 * @export
 * @class VmsApi
 * @extends {BaseAPI}
 */
export class VmsApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Domain Uuid
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public getVm(uuid: string, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).getVm(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Domain
     * @param {boolean} [admin] 
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {string} [nameLike] 
     * @param {string} [nodeNameLike] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public getVms(admin?: boolean, limit?: number, page?: number, nameLike?: string, nodeNameLike?: string, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).getVms(admin, limit, page, nameLike, nodeNameLike, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Domain
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public getVncAddress(token: string, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).getVncAddress(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VmsTaskApi - axios parameter creator
 * @export
 */
export const VmsTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * umount - path = null  mount - path = iso file path
         * @summary Patch Api Tasks Vms Uuid Cdrom
         * @param {string} uuid 
         * @param {CdromForUpdateDomain} [cdromForUpdateDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlVmCdrom: async (uuid: string, cdromForUpdateDomain?: CdromForUpdateDomain, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('controlVmCdrom', 'uuid', uuid)
            const localVarPath = `/api/tasks/vms/{uuid}/cdrom`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cdromForUpdateDomain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {DomainForCreate} [domainForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVm: async (domainForCreate?: DomainForCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainForCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Domains
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVm: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteVm', 'uuid', uuid)
            const localVarPath = `/api/tasks/vms/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish Task To Update Vm List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshVms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Power off required**  Exception: Cannot switch the OVS while the VM is runningOperation not supported: unable to change config on \'network\' network type
         * @summary Patch Api Vm Network
         * @param {string} uuid 
         * @param {NetworkForUpdateDomain} [networkForUpdateDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVmNetwork: async (uuid: string, networkForUpdateDomain?: NetworkForUpdateDomain, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateVmNetwork', 'uuid', uuid)
            const localVarPath = `/api/tasks/vms/{uuid}/network`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkForUpdateDomain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Tasks Vms Uuid Power
         * @param {string} uuid 
         * @param {PowerStatusForUpdateDomain} [powerStatusForUpdateDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVmPowerStatus: async (uuid: string, powerStatusForUpdateDomain?: PowerStatusForUpdateDomain, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateVmPowerStatus', 'uuid', uuid)
            const localVarPath = `/api/tasks/vms/{uuid}/power`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerStatusForUpdateDomain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VmsTaskApi - functional programming interface
 * @export
 */
export const VmsTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VmsTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * umount - path = null  mount - path = iso file path
         * @summary Patch Api Tasks Vms Uuid Cdrom
         * @param {string} uuid 
         * @param {CdromForUpdateDomain} [cdromForUpdateDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async controlVmCdrom(uuid: string, cdromForUpdateDomain?: CdromForUpdateDomain, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.controlVmCdrom(uuid, cdromForUpdateDomain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {DomainForCreate} [domainForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVm(domainForCreate?: DomainForCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVm(domainForCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Api Domains
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVm(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVm(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish Task To Update Vm List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshVms(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshVms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Power off required**  Exception: Cannot switch the OVS while the VM is runningOperation not supported: unable to change config on \'network\' network type
         * @summary Patch Api Vm Network
         * @param {string} uuid 
         * @param {NetworkForUpdateDomain} [networkForUpdateDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVmNetwork(uuid: string, networkForUpdateDomain?: NetworkForUpdateDomain, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVmNetwork(uuid, networkForUpdateDomain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Tasks Vms Uuid Power
         * @param {string} uuid 
         * @param {PowerStatusForUpdateDomain} [powerStatusForUpdateDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVmPowerStatus(uuid: string, powerStatusForUpdateDomain?: PowerStatusForUpdateDomain, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVmPowerStatus(uuid, powerStatusForUpdateDomain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VmsTaskApi - factory interface
 * @export
 */
export const VmsTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VmsTaskApiFp(configuration)
    return {
        /**
         * umount - path = null  mount - path = iso file path
         * @summary Patch Api Tasks Vms Uuid Cdrom
         * @param {string} uuid 
         * @param {CdromForUpdateDomain} [cdromForUpdateDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        controlVmCdrom(uuid: string, cdromForUpdateDomain?: CdromForUpdateDomain, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.controlVmCdrom(uuid, cdromForUpdateDomain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {DomainForCreate} [domainForCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVm(domainForCreate?: DomainForCreate, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.createVm(domainForCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Domains
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVm(uuid: string, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.deleteVm(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish Task To Update Vm List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshVms(options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.refreshVms(options).then((request) => request(axios, basePath));
        },
        /**
         * **Power off required**  Exception: Cannot switch the OVS while the VM is runningOperation not supported: unable to change config on \'network\' network type
         * @summary Patch Api Vm Network
         * @param {string} uuid 
         * @param {NetworkForUpdateDomain} [networkForUpdateDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVmNetwork(uuid: string, networkForUpdateDomain?: NetworkForUpdateDomain, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.updateVmNetwork(uuid, networkForUpdateDomain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Tasks Vms Uuid Power
         * @param {string} uuid 
         * @param {PowerStatusForUpdateDomain} [powerStatusForUpdateDomain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVmPowerStatus(uuid: string, powerStatusForUpdateDomain?: PowerStatusForUpdateDomain, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.updateVmPowerStatus(uuid, powerStatusForUpdateDomain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VmsTaskApi - object-oriented interface
 * @export
 * @class VmsTaskApi
 * @extends {BaseAPI}
 */
export class VmsTaskApi extends BaseAPI {
    /**
     * umount - path = null  mount - path = iso file path
     * @summary Patch Api Tasks Vms Uuid Cdrom
     * @param {string} uuid 
     * @param {CdromForUpdateDomain} [cdromForUpdateDomain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public controlVmCdrom(uuid: string, cdromForUpdateDomain?: CdromForUpdateDomain, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).controlVmCdrom(uuid, cdromForUpdateDomain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Vms
     * @param {DomainForCreate} [domainForCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public createVm(domainForCreate?: DomainForCreate, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).createVm(domainForCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Domains
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public deleteVm(uuid: string, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).deleteVm(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish Task To Update Vm List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public refreshVms(options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).refreshVms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Power off required**  Exception: Cannot switch the OVS while the VM is runningOperation not supported: unable to change config on \'network\' network type
     * @summary Patch Api Vm Network
     * @param {string} uuid 
     * @param {NetworkForUpdateDomain} [networkForUpdateDomain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public updateVmNetwork(uuid: string, networkForUpdateDomain?: NetworkForUpdateDomain, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).updateVmNetwork(uuid, networkForUpdateDomain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Tasks Vms Uuid Power
     * @param {string} uuid 
     * @param {PowerStatusForUpdateDomain} [powerStatusForUpdateDomain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public updateVmPowerStatus(uuid: string, powerStatusForUpdateDomain?: PowerStatusForUpdateDomain, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).updateVmPowerStatus(uuid, powerStatusForUpdateDomain, options).then((request) => request(this.axios, this.basePath));
    }
}


