/* tslint:disable */
/* eslint-disable */
/**
 * VirtyAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthValidate
 */
export interface AuthValidate {
    /**
     * 
     * @type {string}
     * @memberof AuthValidate
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthValidate
     */
    'token_type': string;
    /**
     * 
     * @type {string}
     * @memberof AuthValidate
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface CloudInitInsert
 */
export interface CloudInitInsert {
    /**
     * 
     * @type {string}
     * @memberof CloudInitInsert
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof CloudInitInsert
     */
    'userData': string;
}
/**
 * 
 * @export
 * @interface DeleteProject
 */
export interface DeleteProject {
    /**
     * 
     * @type {string}
     * @memberof DeleteProject
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DomainInsert
 */
export interface DomainInsert {
    /**
     * 
     * @type {string}
     * @memberof DomainInsert
     */
    'type': DomainInsertTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DomainInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsert
     */
    'nodeName': string;
    /**
     * 
     * @type {number}
     * @memberof DomainInsert
     */
    'memoryMegaByte': number;
    /**
     * 
     * @type {number}
     * @memberof DomainInsert
     */
    'cpu': number;
    /**
     * 
     * @type {Array<DomainInsertDisk>}
     * @memberof DomainInsert
     */
    'disks': Array<DomainInsertDisk>;
    /**
     * 
     * @type {Array<DomainInsertInterface>}
     * @memberof DomainInsert
     */
    'interface': Array<DomainInsertInterface>;
    /**
     * 
     * @type {CloudInitInsert}
     * @memberof DomainInsert
     */
    'cloudInit'?: CloudInitInsert;
}

export const DomainInsertTypeEnum = {
    Manual: 'manual',
    Project: 'project'
} as const;

export type DomainInsertTypeEnum = typeof DomainInsertTypeEnum[keyof typeof DomainInsertTypeEnum];

/**
 * 
 * @export
 * @interface DomainInsertDisk
 */
export interface DomainInsertDisk {
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'savePoolUuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'originalPoolUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'originalName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DomainInsertDisk
     */
    'sizeGigaByte'?: number;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'templateName'?: string;
}
/**
 * 
 * @export
 * @interface DomainInsertInterface
 */
export interface DomainInsertInterface {
    /**
     * 
     * @type {string}
     * @memberof DomainInsertInterface
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertInterface
     */
    'mac'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertInterface
     */
    'networkUuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertInterface
     */
    'port'?: string;
}
/**
 * 
 * @export
 * @interface DomainNetworkChange
 */
export interface DomainNetworkChange {
    /**
     * 
     * @type {string}
     * @memberof DomainNetworkChange
     */
    'mac': string;
    /**
     * 
     * @type {string}
     * @memberof DomainNetworkChange
     */
    'networkUuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainNetworkChange
     */
    'port'?: string;
}
/**
 * 
 * @export
 * @interface GetDomain
 */
export interface GetDomain {
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GetDomain
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof GetDomain
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof GetDomain
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'ownerProjectId'?: string;
    /**
     * 
     * @type {GetDomainProject}
     * @memberof GetDomain
     */
    'ownerProject'?: GetDomainProject;
    /**
     * 
     * @type {number}
     * @memberof GetDomain
     */
    'vncPort'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'vncPassword'?: string;
    /**
     * 
     * @type {Array<GetDomainDrives>}
     * @memberof GetDomain
     */
    'drives'?: Array<GetDomainDrives>;
    /**
     * 
     * @type {Array<GetDomainInterfaces>}
     * @memberof GetDomain
     */
    'interfaces'?: Array<GetDomainInterfaces>;
}
/**
 * 
 * @export
 * @interface GetDomainDetail
 */
export interface GetDomainDetail {
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GetDomainDetail
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof GetDomainDetail
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof GetDomainDetail
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'ownerProjectId'?: string;
    /**
     * 
     * @type {GetDomainProject}
     * @memberof GetDomainDetail
     */
    'ownerProject'?: GetDomainProject;
    /**
     * 
     * @type {number}
     * @memberof GetDomainDetail
     */
    'vncPort'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'vncPassword'?: string;
    /**
     * 
     * @type {Array<GetDomainDrives>}
     * @memberof GetDomainDetail
     */
    'drives'?: Array<GetDomainDrives>;
    /**
     * 
     * @type {Array<GetDomainInterfaces>}
     * @memberof GetDomainDetail
     */
    'interfaces'?: Array<GetDomainInterfaces>;
    /**
     * 
     * @type {GetNode}
     * @memberof GetDomainDetail
     */
    'node': GetNode;
}
/**
 * 
 * @export
 * @interface GetDomainDrives
 */
export interface GetDomainDrives {
    /**
     * 
     * @type {string}
     * @memberof GetDomainDrives
     */
    'device'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDrives
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDrives
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDrives
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface GetDomainInterfaces
 */
export interface GetDomainInterfaces {
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'mac'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'bridge'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'port'?: string;
}
/**
 * 
 * @export
 * @interface GetDomainPagenation
 */
export interface GetDomainPagenation {
    /**
     * 
     * @type {number}
     * @memberof GetDomainPagenation
     */
    'count': number;
    /**
     * 
     * @type {Array<GetDomain>}
     * @memberof GetDomainPagenation
     */
    'data': Array<GetDomain>;
}
/**
 * 
 * @export
 * @interface GetDomainProject
 */
export interface GetDomainProject {
    /**
     * 
     * @type {string}
     * @memberof GetDomainProject
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainProject
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GetFlavor
 */
export interface GetFlavor {
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'os': string;
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'manualUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetFlavor
     */
    'cloudInitReady': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof GetFlavor
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface GetImageDomain
 */
export interface GetImageDomain {
    /**
     * 
     * @type {string}
     * @memberof GetImageDomain
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetImageDomain
     */
    'issuanceId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetImageDomain
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetImageDomain
     */
    'uuid': string;
}
/**
 * 
 * @export
 * @interface GetNEtworkPoolNetworksNetwork
 */
export interface GetNEtworkPoolNetworksNetwork {
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'bridge': string;
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface GetNetwork
 */
export interface GetNetwork {
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetNetwork
     */
    'dhcp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetNetwork
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'bridge'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetNetwork
     */
    'autoStart'?: boolean;
    /**
     * 
     * @type {Array<NetworkPortgroup>}
     * @memberof GetNetwork
     */
    'portgroups': Array<NetworkPortgroup>;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'updateToken'?: string;
}
/**
 * 
 * @export
 * @interface GetNetworkPool
 */
export interface GetNetworkPool {
    /**
     * 
     * @type {number}
     * @memberof GetNetworkPool
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkPool
     */
    'name'?: string;
    /**
     * 
     * @type {Array<GetNEtworkPoolNetworksNetwork>}
     * @memberof GetNetworkPool
     */
    'networks'?: Array<GetNEtworkPoolNetworksNetwork>;
    /**
     * 
     * @type {Array<GetNetworkPoolPort>}
     * @memberof GetNetworkPool
     */
    'ports'?: Array<GetNetworkPoolPort>;
}
/**
 * 
 * @export
 * @interface GetNetworkPoolPort
 */
export interface GetNetworkPoolPort {
    /**
     * 
     * @type {string}
     * @memberof GetNetworkPoolPort
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetNetworkPoolPort
     */
    'vlanId'?: number;
    /**
     * 
     * @type {GetNEtworkPoolNetworksNetwork}
     * @memberof GetNetworkPoolPort
     */
    'network': GetNEtworkPoolNetworksNetwork;
}
/**
 * 
 * @export
 * @interface GetNode
 */
export interface GetNode {
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'userName': string;
    /**
     * 
     * @type {number}
     * @memberof GetNode
     */
    'port': number;
    /**
     * 
     * @type {number}
     * @memberof GetNode
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof GetNode
     */
    'memory': number;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'cpuGen': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'osLike': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'osName': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'osVersion': string;
    /**
     * 
     * @type {number}
     * @memberof GetNode
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'qemuVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'libvirtVersion'?: string;
    /**
     * 
     * @type {Array<GetNodeRole>}
     * @memberof GetNode
     */
    'roles': Array<GetNodeRole>;
}
/**
 * 
 * @export
 * @interface GetNodeRole
 */
export interface GetNodeRole {
    /**
     * 
     * @type {string}
     * @memberof GetNodeRole
     */
    'roleName': string;
    /**
     * 
     * @type {object}
     * @memberof GetNodeRole
     */
    'extraJson'?: object;
}
/**
 * 
 * @export
 * @interface GetStoragePool
 */
export interface GetStoragePool {
    /**
     * 
     * @type {number}
     * @memberof GetStoragePool
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetStoragePool
     */
    'name': string;
    /**
     * 
     * @type {Array<GetStoragePoolStorages>}
     * @memberof GetStoragePool
     */
    'storages': Array<GetStoragePoolStorages>;
}
/**
 * 
 * @export
 * @interface GetStoragePoolStorages
 */
export interface GetStoragePoolStorages {
    /**
     * 
     * @type {GetStoragePoolStoragesStorage}
     * @memberof GetStoragePoolStorages
     */
    'storage': GetStoragePoolStoragesStorage;
}
/**
 * 
 * @export
 * @interface GetStoragePoolStoragesStorage
 */
export interface GetStoragePoolStoragesStorage {
    /**
     * 
     * @type {string}
     * @memberof GetStoragePoolStoragesStorage
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetStoragePoolStoragesStorage
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetStoragePoolStoragesStorage
     */
    'nodeName': string;
}
/**
 * 
 * @export
 * @interface GetUserProject
 */
export interface GetUserProject {
    /**
     * 
     * @type {string}
     * @memberof GetUserProject
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GetUserScope
 */
export interface GetUserScope {
    /**
     * 
     * @type {string}
     * @memberof GetUserScope
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GetUsers
 */
export interface GetUsers {
    /**
     * 
     * @type {string}
     * @memberof GetUsers
     */
    'username': string;
    /**
     * 
     * @type {Array<GetUserScope>}
     * @memberof GetUsers
     */
    'scopes': Array<GetUserScope>;
    /**
     * 
     * @type {Array<GetUserProject>}
     * @memberof GetUsers
     */
    'projects': Array<GetUserProject>;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface ImageSCP
 */
export interface ImageSCP {
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'fromNodeName': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'toNodeName': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'fromFilePath': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'toFilePath': string;
}
/**
 * 
 * @export
 * @interface ImageSelect
 */
export interface ImageSelect {
    /**
     * 
     * @type {string}
     * @memberof ImageSelect
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSelect
     */
    'storageUuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ImageSelect
     */
    'capacity': number;
    /**
     * 
     * @type {StorageSelect}
     * @memberof ImageSelect
     */
    'storage': StorageSelect;
    /**
     * 
     * @type {GetFlavor}
     * @memberof ImageSelect
     */
    'flavor'?: GetFlavor;
    /**
     * 
     * @type {number}
     * @memberof ImageSelect
     */
    'allocation': number;
    /**
     * 
     * @type {string}
     * @memberof ImageSelect
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSelect
     */
    'updateToken'?: string;
    /**
     * 
     * @type {GetImageDomain}
     * @memberof ImageSelect
     */
    'domain'?: GetImageDomain;
}
/**
 * 
 * @export
 * @interface NetworkInsert
 */
export interface NetworkInsert {
    /**
     * 
     * @type {string}
     * @memberof NetworkInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInsert
     */
    'nodeName': string;
    /**
     * brdige or ovs
     * @type {string}
     * @memberof NetworkInsert
     */
    'type': NetworkInsertTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NetworkInsert
     */
    'bridgeDevice'?: string;
}

export const NetworkInsertTypeEnum = {
    Bridge: 'bridge',
    Ovs: 'ovs'
} as const;

export type NetworkInsertTypeEnum = typeof NetworkInsertTypeEnum[keyof typeof NetworkInsertTypeEnum];

/**
 * 
 * @export
 * @interface NetworkOVSAdd
 */
export interface NetworkOVSAdd {
    /**
     * 
     * @type {boolean}
     * @memberof NetworkOVSAdd
     */
    'default': boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkOVSAdd
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof NetworkOVSAdd
     */
    'vlanId'?: number;
}
/**
 * 
 * @export
 * @interface NetworkPortgroup
 */
export interface NetworkPortgroup {
    /**
     * 
     * @type {string}
     * @memberof NetworkPortgroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkPortgroup
     */
    'vlanId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkPortgroup
     */
    'isDefault': boolean;
}
/**
 * 
 * @export
 * @interface NodeInsert
 */
export interface NodeInsert {
    /**
     * 
     * @type {string}
     * @memberof NodeInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NodeInsert
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof NodeInsert
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof NodeInsert
     */
    'userName': string;
    /**
     * 
     * @type {number}
     * @memberof NodeInsert
     */
    'port': number;
    /**
     * 
     * @type {boolean}
     * @memberof NodeInsert
     */
    'libvirtRole': boolean;
}
/**
 * 
 * @export
 * @interface NodeRolePatch
 */
export interface NodeRolePatch {
    /**
     * 
     * @type {string}
     * @memberof NodeRolePatch
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof NodeRolePatch
     */
    'roleName': string;
    /**
     * 
     * @type {object}
     * @memberof NodeRolePatch
     */
    'extraJson'?: object;
}
/**
 * 
 * @export
 * @interface PatchDomainPower
 */
export interface PatchDomainPower {
    /**
     * 
     * @type {string}
     * @memberof PatchDomainPower
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface PatchDominCdrom
 */
export interface PatchDominCdrom {
    /**
     * 
     * @type {string}
     * @memberof PatchDominCdrom
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchDominCdrom
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface PatchImageFlavor
 */
export interface PatchImageFlavor {
    /**
     * 
     * @type {string}
     * @memberof PatchImageFlavor
     */
    'storageUuid': string;
    /**
     * 
     * @type {string}
     * @memberof PatchImageFlavor
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof PatchImageFlavor
     */
    'nodeName': string;
    /**
     * 
     * @type {number}
     * @memberof PatchImageFlavor
     */
    'flavorId': number;
}
/**
 * 
 * @export
 * @interface PatchNetworkPool
 */
export interface PatchNetworkPool {
    /**
     * 
     * @type {number}
     * @memberof PatchNetworkPool
     */
    'poolId': number;
    /**
     * 
     * @type {string}
     * @memberof PatchNetworkPool
     */
    'networkUuid': string;
    /**
     * 
     * @type {string}
     * @memberof PatchNetworkPool
     */
    'portName'?: string;
}
/**
 * 
 * @export
 * @interface PatchStoragePool
 */
export interface PatchStoragePool {
    /**
     * 
     * @type {string}
     * @memberof PatchStoragePool
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchStoragePool
     */
    'storageUuids': Array<string>;
}
/**
 * 
 * @export
 * @interface PostFlavor
 */
export interface PostFlavor {
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'os': string;
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'manualUrl': string;
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof PostFlavor
     */
    'cloudInitReady': boolean;
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface PostNetworkPool
 */
export interface PostNetworkPool {
    /**
     * 
     * @type {string}
     * @memberof PostNetworkPool
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PostProject
 */
export interface PostProject {
    /**
     * 
     * @type {string}
     * @memberof PostProject
     */
    'projectName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostProject
     */
    'userIds': Array<string>;
}
/**
 * 
 * @export
 * @interface PostStoragePool
 */
export interface PostStoragePool {
    /**
     * 
     * @type {string}
     * @memberof PostStoragePool
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostStoragePool
     */
    'storageUuids': Array<string>;
}
/**
 * 
 * @export
 * @interface ProjectPatch
 */
export interface ProjectPatch {
    /**
     * 
     * @type {string}
     * @memberof ProjectPatch
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPatch
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface ProjectSelect
 */
export interface ProjectSelect {
    /**
     * 
     * @type {string}
     * @memberof ProjectSelect
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectSelect
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectSelect
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectSelect
     */
    'memoryG': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectSelect
     */
    'storageCapacityG': number;
    /**
     * 
     * @type {Array<UserBase>}
     * @memberof ProjectSelect
     */
    'users': Array<UserBase>;
    /**
     * 
     * @type {number}
     * @memberof ProjectSelect
     */
    'usedMemoryG': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectSelect
     */
    'usedCore': number;
    /**
     * 
     * @type {any}
     * @memberof ProjectSelect
     */
    'networkPools'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProjectSelect
     */
    'storagePools'?: any;
}
/**
 * 
 * @export
 * @interface SSHKeyPair
 */
export interface SSHKeyPair {
    /**
     * 
     * @type {string}
     * @memberof SSHKeyPair
     */
    'privateKey': string;
    /**
     * 
     * @type {string}
     * @memberof SSHKeyPair
     */
    'publicKey': string;
}
/**
 * 
 * @export
 * @interface Setup
 */
export interface Setup {
    /**
     * 
     * @type {string}
     * @memberof Setup
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Setup
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface StorageInsert
 */
export interface StorageInsert {
    /**
     * 
     * @type {string}
     * @memberof StorageInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageInsert
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof StorageInsert
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface StorageMetadataPatch
 */
export interface StorageMetadataPatch {
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataPatch
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataPatch
     */
    'rool': string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataPatch
     */
    'protocol': string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataPatch
     */
    'deviceType': string;
}
/**
 * 
 * @export
 * @interface StorageMetadataSelect
 */
export interface StorageMetadataSelect {
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataSelect
     */
    'rool'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataSelect
     */
    'protocol'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataSelect
     */
    'deviceType'?: string;
}
/**
 * 
 * @export
 * @interface StorageSelect
 */
export interface StorageSelect {
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'uuid': string;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'status': number;
    /**
     * 
     * @type {boolean}
     * @memberof StorageSelect
     */
    'active': boolean;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'available'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'capacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'nodeName': string;
    /**
     * 
     * @type {GetNode}
     * @memberof StorageSelect
     */
    'node': GetNode;
    /**
     * 
     * @type {boolean}
     * @memberof StorageSelect
     */
    'autoStart': boolean;
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'path'?: string;
    /**
     * 
     * @type {StorageMetadataSelect}
     * @memberof StorageSelect
     */
    'metaData'?: StorageMetadataSelect;
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'updateToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'allocationCommit'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'capacityCommit'?: number;
}
/**
 * 
 * @export
 * @interface TaskIncomplete
 */
export interface TaskIncomplete {
    /**
     * 
     * @type {string}
     * @memberof TaskIncomplete
     */
    'hash': string;
    /**
     * 
     * @type {number}
     * @memberof TaskIncomplete
     */
    'count': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskIncomplete
     */
    'uuids': Array<string>;
}
/**
 * 
 * @export
 * @interface TaskPagesnation
 */
export interface TaskPagesnation {
    /**
     * 
     * @type {number}
     * @memberof TaskPagesnation
     */
    'count': number;
    /**
     * 
     * @type {Array<TaskSelect>}
     * @memberof TaskPagesnation
     */
    'data': Array<TaskSelect>;
}
/**
 * 
 * @export
 * @interface TaskSelect
 */
export interface TaskSelect {
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'postTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskSelect
     */
    'runTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'resource'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'method'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'dependenceUuid'?: string;
    /**
     * 
     * @type {object}
     * @memberof TaskSelect
     */
    'request'?: object;
    /**
     * 
     * @type {object}
     * @memberof TaskSelect
     */
    'result'?: object;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'log'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'uuid'?: string;
}
/**
 * 
 * @export
 * @interface TokenData
 */
export interface TokenData {
    /**
     * 
     * @type {string}
     * @memberof TokenData
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TokenData
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TokenData
     */
    'role'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TokenRFC6749Response
 */
export interface TokenRFC6749Response {
    /**
     * 
     * @type {string}
     * @memberof TokenRFC6749Response
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRFC6749Response
     */
    'token_type': string;
}
/**
 * 
 * @export
 * @interface UserBase
 */
export interface UserBase {
    /**
     * 
     * @type {string}
     * @memberof UserBase
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserInsert
 */
export interface UserInsert {
    /**
     * 
     * @type {string}
     * @memberof UserInsert
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserInsert
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    'loc': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * 
     * @type {boolean}
     * @memberof Version
     */
    'initialized': boolean;
    /**
     * 
     * @type {string}
     * @memberof Version
     */
    'version': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Api Auth Setup
         * @param {Setup} setup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSetupApiAuthSetupPost: async (setup: Setup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setup' is not null or undefined
            assertParamExists('apiAuthSetupApiAuthSetupPost', 'setup', setup)
            const localVarPath = `/api/auth/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiAuthPost: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginForAccessTokenApiAuthPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginForAccessTokenApiAuthPost', 'password', password)
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuthValidateApiAuthValidateGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Api Auth Setup
         * @param {Setup} setup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthSetupApiAuthSetupPost(setup: Setup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthSetupApiAuthSetupPost(setup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginForAccessTokenApiAuthPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRFC6749Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginForAccessTokenApiAuthPost(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAuthValidateApiAuthValidateGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthValidate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAuthValidateApiAuthValidateGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Api Auth Setup
         * @param {Setup} setup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSetupApiAuthSetupPost(setup: Setup, options?: any): AxiosPromise<any> {
            return localVarFp.apiAuthSetupApiAuthSetupPost(setup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiAuthPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<TokenRFC6749Response> {
            return localVarFp.loginForAccessTokenApiAuthPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuthValidateApiAuthValidateGet(options?: any): AxiosPromise<AuthValidate> {
            return localVarFp.readAuthValidateApiAuthValidateGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Api Auth Setup
     * @param {Setup} setup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthSetupApiAuthSetupPost(setup: Setup, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthSetupApiAuthSetupPost(setup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login For Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginForAccessTokenApiAuthPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginForAccessTokenApiAuthPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Auth Validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public readAuthValidateApiAuthValidateGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).readAuthValidateApiAuthValidateGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FlavorsApi - axios parameter creator
 * @export
 */
export const FlavorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiFlavorsApiFlavorsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Flavors
         * @param {PostFlavor} postFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiFlavorsApiFlavorsPost: async (postFlavor: PostFlavor, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postFlavor' is not null or undefined
            assertParamExists('postApiFlavorsApiFlavorsPost', 'postFlavor', postFlavor)
            const localVarPath = `/api/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postFlavor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlavorsApi - functional programming interface
 * @export
 */
export const FlavorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlavorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiFlavorsApiFlavorsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFlavor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiFlavorsApiFlavorsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Flavors
         * @param {PostFlavor} postFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiFlavorsApiFlavorsPost(postFlavor: PostFlavor, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiFlavorsApiFlavorsPost(postFlavor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FlavorsApi - factory interface
 * @export
 */
export const FlavorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlavorsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiFlavorsApiFlavorsGet(options?: any): AxiosPromise<Array<GetFlavor>> {
            return localVarFp.getApiFlavorsApiFlavorsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Flavors
         * @param {PostFlavor} postFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiFlavorsApiFlavorsPost(postFlavor: PostFlavor, options?: any): AxiosPromise<any> {
            return localVarFp.postApiFlavorsApiFlavorsPost(postFlavor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlavorsApi - object-oriented interface
 * @export
 * @class FlavorsApi
 * @extends {BaseAPI}
 */
export class FlavorsApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Flavors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public getApiFlavorsApiFlavorsGet(options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).getApiFlavorsApiFlavorsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Flavors
     * @param {PostFlavor} postFlavor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public postApiFlavorsApiFlavorsPost(postFlavor: PostFlavor, options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).postApiFlavorsApiFlavorsPost(postFlavor, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Images
         * @param {string} [nodeName] 
         * @param {string} [poolUuid] 
         * @param {string} [name] 
         * @param {string} [rool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiImagesApiImagesGet: async (nodeName?: string, poolUuid?: string, name?: string, rool?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (nodeName !== undefined) {
                localVarQueryParameter['node_name'] = nodeName;
            }

            if (poolUuid !== undefined) {
                localVarQueryParameter['pool_uuid'] = poolUuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (rool !== undefined) {
                localVarQueryParameter['rool'] = rool;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Images
         * @param {PatchImageFlavor} patchImageFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiImagesApiImagesPatch: async (patchImageFlavor: PatchImageFlavor, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchImageFlavor' is not null or undefined
            assertParamExists('patchApiImagesApiImagesPatch', 'patchImageFlavor', patchImageFlavor)
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchImageFlavor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Images Scp
         * @param {ImageSCP} [imageSCP] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiImagesScpApiImagesScpPut: async (imageSCP?: ImageSCP, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images/scp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageSCP, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Images
         * @param {string} [nodeName] 
         * @param {string} [poolUuid] 
         * @param {string} [name] 
         * @param {string} [rool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiImagesApiImagesGet(nodeName?: string, poolUuid?: string, name?: string, rool?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiImagesApiImagesGet(nodeName, poolUuid, name, rool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Images
         * @param {PatchImageFlavor} patchImageFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiImagesApiImagesPatch(patchImageFlavor: PatchImageFlavor, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiImagesApiImagesPatch(patchImageFlavor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Images Scp
         * @param {ImageSCP} [imageSCP] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putApiImagesScpApiImagesScpPut(imageSCP?: ImageSCP, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putApiImagesScpApiImagesScpPut(imageSCP, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Images
         * @param {string} [nodeName] 
         * @param {string} [poolUuid] 
         * @param {string} [name] 
         * @param {string} [rool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiImagesApiImagesGet(nodeName?: string, poolUuid?: string, name?: string, rool?: string, options?: any): AxiosPromise<Array<ImageSelect>> {
            return localVarFp.getApiImagesApiImagesGet(nodeName, poolUuid, name, rool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Images
         * @param {PatchImageFlavor} patchImageFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiImagesApiImagesPatch(patchImageFlavor: PatchImageFlavor, options?: any): AxiosPromise<any> {
            return localVarFp.patchApiImagesApiImagesPatch(patchImageFlavor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Images Scp
         * @param {ImageSCP} [imageSCP] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiImagesScpApiImagesScpPut(imageSCP?: ImageSCP, options?: any): AxiosPromise<any> {
            return localVarFp.putApiImagesScpApiImagesScpPut(imageSCP, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Images
     * @param {string} [nodeName] 
     * @param {string} [poolUuid] 
     * @param {string} [name] 
     * @param {string} [rool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public getApiImagesApiImagesGet(nodeName?: string, poolUuid?: string, name?: string, rool?: string, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).getApiImagesApiImagesGet(nodeName, poolUuid, name, rool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Images
     * @param {PatchImageFlavor} patchImageFlavor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public patchApiImagesApiImagesPatch(patchImageFlavor: PatchImageFlavor, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).patchApiImagesApiImagesPatch(patchImageFlavor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Images Scp
     * @param {ImageSCP} [imageSCP] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public putApiImagesScpApiImagesScpPut(imageSCP?: ImageSCP, options?: AxiosRequestConfig) {
        return ImagesApiFp(this.configuration).putApiImagesScpApiImagesScpPut(imageSCP, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImagesTaskApi - axios parameter creator
 * @export
 */
export const ImagesTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Put Api Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiImagesApiTasksImagesPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesTaskApi - functional programming interface
 * @export
 */
export const ImagesTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Put Api Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putApiImagesApiTasksImagesPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putApiImagesApiTasksImagesPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImagesTaskApi - factory interface
 * @export
 */
export const ImagesTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesTaskApiFp(configuration)
    return {
        /**
         * 
         * @summary Put Api Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiImagesApiTasksImagesPut(options?: any): AxiosPromise<any> {
            return localVarFp.putApiImagesApiTasksImagesPut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesTaskApi - object-oriented interface
 * @export
 * @class ImagesTaskApi
 * @extends {BaseAPI}
 */
export class ImagesTaskApi extends BaseAPI {
    /**
     * 
     * @summary Put Api Images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesTaskApi
     */
    public putApiImagesApiTasksImagesPut(options?: AxiosRequestConfig) {
        return ImagesTaskApiFp(this.configuration).putApiImagesApiTasksImagesPut(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exporter Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exporterGetApiMetricsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Exporter Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exporterGetApiMetricsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exporterGetApiMetricsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Exporter Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exporterGetApiMetricsGet(options?: any): AxiosPromise<string> {
            return localVarFp.exporterGetApiMetricsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Exporter Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public exporterGetApiMetricsGet(options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).exporterGetApiMetricsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MixinApi - axios parameter creator
 * @export
 */
export const MixinApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 初期化済みか判定用
         * @summary Get Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionApiVersionGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MixinApi - functional programming interface
 * @export
 */
export const MixinApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MixinApiAxiosParamCreator(configuration)
    return {
        /**
         * 初期化済みか判定用
         * @summary Get Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionApiVersionGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersionApiVersionGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MixinApi - factory interface
 * @export
 */
export const MixinApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MixinApiFp(configuration)
    return {
        /**
         * 初期化済みか判定用
         * @summary Get Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionApiVersionGet(options?: any): AxiosPromise<Version> {
            return localVarFp.getVersionApiVersionGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MixinApi - object-oriented interface
 * @export
 * @class MixinApi
 * @extends {BaseAPI}
 */
export class MixinApi extends BaseAPI {
    /**
     * 初期化済みか判定用
     * @summary Get Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MixinApi
     */
    public getVersionApiVersionGet(options?: AxiosRequestConfig) {
        return MixinApiFp(this.configuration).getVersionApiVersionGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworksApi - axios parameter creator
 * @export
 */
export const NetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Pools Uuid
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoolsUuidApiNetworksPoolsIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePoolsUuidApiNetworksPoolsIdDelete', 'id', id)
            const localVarPath = `/api/networks/pools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksApiNetworksGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Networks Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksPoolsApiNetworksPoolsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Networks Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksUuidApiNetworksUuidGet: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getApiNetworksUuidApiNetworksUuidGet', 'uuid', uuid)
            const localVarPath = `/api/networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Networks Pools
         * @param {PatchNetworkPool} patchNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNetworksPoolsApiNetworksPoolsPatch: async (patchNetworkPool: PatchNetworkPool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchNetworkPool' is not null or undefined
            assertParamExists('patchApiNetworksPoolsApiNetworksPoolsPatch', 'patchNetworkPool', patchNetworkPool)
            const localVarPath = `/api/networks/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchNetworkPool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Networks Pools
         * @param {PostNetworkPool} postNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksPoolsApiNetworksPoolsPost: async (postNetworkPool: PostNetworkPool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postNetworkPool' is not null or undefined
            assertParamExists('postApiNetworksPoolsApiNetworksPoolsPost', 'postNetworkPool', postNetworkPool)
            const localVarPath = `/api/networks/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postNetworkPool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworksApi - functional programming interface
 * @export
 */
export const NetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Pools Uuid
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePoolsUuidApiNetworksPoolsIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePoolsUuidApiNetworksPoolsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNetworksApiNetworksGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetNetwork>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNetworksApiNetworksGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Networks Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNetworksPoolsApiNetworksPoolsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetNetworkPool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNetworksPoolsApiNetworksPoolsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Networks Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNetworksUuidApiNetworksUuidGet(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNetworksUuidApiNetworksUuidGet(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Networks Pools
         * @param {PatchNetworkPool} patchNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool: PatchNetworkPool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Networks Pools
         * @param {PostNetworkPool} postNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool: PostNetworkPool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworksApi - factory interface
 * @export
 */
export const NetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Pools Uuid
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoolsUuidApiNetworksPoolsIdDelete(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deletePoolsUuidApiNetworksPoolsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksApiNetworksGet(options?: any): AxiosPromise<Array<GetNetwork>> {
            return localVarFp.getApiNetworksApiNetworksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Networks Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksPoolsApiNetworksPoolsGet(options?: any): AxiosPromise<Array<GetNetworkPool>> {
            return localVarFp.getApiNetworksPoolsApiNetworksPoolsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Networks Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksUuidApiNetworksUuidGet(uuid: string, options?: any): AxiosPromise<GetNetwork> {
            return localVarFp.getApiNetworksUuidApiNetworksUuidGet(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Networks Pools
         * @param {PatchNetworkPool} patchNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool: PatchNetworkPool, options?: any): AxiosPromise<any> {
            return localVarFp.patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Networks Pools
         * @param {PostNetworkPool} postNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool: PostNetworkPool, options?: any): AxiosPromise<any> {
            return localVarFp.postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworksApi - object-oriented interface
 * @export
 * @class NetworksApi
 * @extends {BaseAPI}
 */
export class NetworksApi extends BaseAPI {
    /**
     * 
     * @summary Delete Pools Uuid
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public deletePoolsUuidApiNetworksPoolsIdDelete(id: number, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).deletePoolsUuidApiNetworksPoolsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public getApiNetworksApiNetworksGet(options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).getApiNetworksApiNetworksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Networks Pools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public getApiNetworksPoolsApiNetworksPoolsGet(options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).getApiNetworksPoolsApiNetworksPoolsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Networks Uuid
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public getApiNetworksUuidApiNetworksUuidGet(uuid: string, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).getApiNetworksUuidApiNetworksUuidGet(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Networks Pools
     * @param {PatchNetworkPool} patchNetworkPool 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool: PatchNetworkPool, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Networks Pools
     * @param {PostNetworkPool} postNetworkPool 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool: PostNetworkPool, options?: AxiosRequestConfig) {
        return NetworksApiFp(this.configuration).postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworksTaskApi - axios parameter creator
 * @export
 */
export const NetworksTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Api Storage
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiStorageApiTasksNetworksUuidDelete: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteApiStorageApiTasksNetworksUuidDelete', 'uuid', uuid)
            const localVarPath = `/api/tasks/networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {string} uuid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksUuidOvsApiTasksNetworksUuidOvsNameDelete: async (uuid: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('postApiNetworksUuidOvsApiTasksNetworksUuidOvsNameDelete', 'uuid', uuid)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postApiNetworksUuidOvsApiTasksNetworksUuidOvsNameDelete', 'name', name)
            const localVarPath = `/api/tasks/networks/{uuid}/ovs/{name}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkInsert} [networkInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiTasksNetworksPost: async (networkInsert?: NetworkInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Uuid Ovs
         * @param {string} uuid 
         * @param {NetworkOVSAdd} [networkOVSAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUuidOvsApiTasksNetworksUuidOvsPost: async (uuid: string, networkOVSAdd?: NetworkOVSAdd, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('postUuidOvsApiTasksNetworksUuidOvsPost', 'uuid', uuid)
            const localVarPath = `/api/tasks/networks/{uuid}/ovs`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkOVSAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiNetworksApiTasksNetworksPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworksTaskApi - functional programming interface
 * @export
 */
export const NetworksTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworksTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Api Storage
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiStorageApiTasksNetworksUuidDelete(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiStorageApiTasksNetworksUuidDelete(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {string} uuid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiNetworksUuidOvsApiTasksNetworksUuidOvsNameDelete(uuid: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiNetworksUuidOvsApiTasksNetworksUuidOvsNameDelete(uuid, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkInsert} [networkInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStorageApiTasksNetworksPost(networkInsert?: NetworkInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStorageApiTasksNetworksPost(networkInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Uuid Ovs
         * @param {string} uuid 
         * @param {NetworkOVSAdd} [networkOVSAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUuidOvsApiTasksNetworksUuidOvsPost(uuid: string, networkOVSAdd?: NetworkOVSAdd, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUuidOvsApiTasksNetworksUuidOvsPost(uuid, networkOVSAdd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putApiNetworksApiTasksNetworksPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putApiNetworksApiTasksNetworksPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworksTaskApi - factory interface
 * @export
 */
export const NetworksTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworksTaskApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Api Storage
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiStorageApiTasksNetworksUuidDelete(uuid: string, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.deleteApiStorageApiTasksNetworksUuidDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {string} uuid 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksUuidOvsApiTasksNetworksUuidOvsNameDelete(uuid: string, name: string, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.postApiNetworksUuidOvsApiTasksNetworksUuidOvsNameDelete(uuid, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkInsert} [networkInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiTasksNetworksPost(networkInsert?: NetworkInsert, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.postApiStorageApiTasksNetworksPost(networkInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Uuid Ovs
         * @param {string} uuid 
         * @param {NetworkOVSAdd} [networkOVSAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUuidOvsApiTasksNetworksUuidOvsPost(uuid: string, networkOVSAdd?: NetworkOVSAdd, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.postUuidOvsApiTasksNetworksUuidOvsPost(uuid, networkOVSAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiNetworksApiTasksNetworksPut(options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.putApiNetworksApiTasksNetworksPut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworksTaskApi - object-oriented interface
 * @export
 * @class NetworksTaskApi
 * @extends {BaseAPI}
 */
export class NetworksTaskApi extends BaseAPI {
    /**
     * 
     * @summary Delete Api Storage
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public deleteApiStorageApiTasksNetworksUuidDelete(uuid: string, options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).deleteApiStorageApiTasksNetworksUuidDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Networks Uuid Ovs
     * @param {string} uuid 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public postApiNetworksUuidOvsApiTasksNetworksUuidOvsNameDelete(uuid: string, name: string, options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).postApiNetworksUuidOvsApiTasksNetworksUuidOvsNameDelete(uuid, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storage
     * @param {NetworkInsert} [networkInsert] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public postApiStorageApiTasksNetworksPost(networkInsert?: NetworkInsert, options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).postApiStorageApiTasksNetworksPost(networkInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Uuid Ovs
     * @param {string} uuid 
     * @param {NetworkOVSAdd} [networkOVSAdd] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public postUuidOvsApiTasksNetworksUuidOvsPost(uuid: string, networkOVSAdd?: NetworkOVSAdd, options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).postUuidOvsApiTasksNetworksUuidOvsPost(uuid, networkOVSAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksTaskApi
     */
    public putApiNetworksApiTasksNetworksPut(options?: AxiosRequestConfig) {
        return NetworksTaskApiFp(this.configuration).putApiNetworksApiTasksNetworksPut(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNodesApiNodesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Nodes
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNodesApiNodesNameGet: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getApiNodesApiNodesNameGet', 'name', name)
            const localVarPath = `/api/nodes/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Node Name Facts
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeNameFactsApiNodesNameFactsGet: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getNodeNameFactsApiNodesNameFactsGet', 'name', name)
            const localVarPath = `/api/nodes/{name}/facts`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshKeyPairApiNodesKeyGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Ssh Key Pair
         * @param {SSHKeyPair} sSHKeyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSshKeyPairApiNodesKeyPost: async (sSHKeyPair: SSHKeyPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sSHKeyPair' is not null or undefined
            assertParamExists('postSshKeyPairApiNodesKeyPost', 'sSHKeyPair', sSHKeyPair)
            const localVarPath = `/api/nodes/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sSHKeyPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNodesApiNodesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetNode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNodesApiNodesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Nodes
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNodesApiNodesNameGet(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNodesApiNodesNameGet(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Node Name Facts
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeNameFactsApiNodesNameFactsGet(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeNameFactsApiNodesNameFactsGet(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSshKeyPairApiNodesKeyGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSHKeyPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSshKeyPairApiNodesKeyGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Ssh Key Pair
         * @param {SSHKeyPair} sSHKeyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSshKeyPairApiNodesKeyPost(sSHKeyPair: SSHKeyPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSshKeyPairApiNodesKeyPost(sSHKeyPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNodesApiNodesGet(options?: any): AxiosPromise<Array<GetNode>> {
            return localVarFp.getApiNodesApiNodesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Nodes
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNodesApiNodesNameGet(name: string, options?: any): AxiosPromise<GetNode> {
            return localVarFp.getApiNodesApiNodesNameGet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Node Name Facts
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeNameFactsApiNodesNameFactsGet(name: string, options?: any): AxiosPromise<any> {
            return localVarFp.getNodeNameFactsApiNodesNameFactsGet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshKeyPairApiNodesKeyGet(options?: any): AxiosPromise<SSHKeyPair> {
            return localVarFp.getSshKeyPairApiNodesKeyGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Ssh Key Pair
         * @param {SSHKeyPair} sSHKeyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSshKeyPairApiNodesKeyPost(sSHKeyPair: SSHKeyPair, options?: any): AxiosPromise<any> {
            return localVarFp.postSshKeyPairApiNodesKeyPost(sSHKeyPair, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getApiNodesApiNodesGet(options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getApiNodesApiNodesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Nodes
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getApiNodesApiNodesNameGet(name: string, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getApiNodesApiNodesNameGet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Node Name Facts
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNodeNameFactsApiNodesNameFactsGet(name: string, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getNodeNameFactsApiNodesNameFactsGet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Ssh Key Pair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getSshKeyPairApiNodesKeyGet(options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getSshKeyPairApiNodesKeyGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Ssh Key Pair
     * @param {SSHKeyPair} sSHKeyPair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public postSshKeyPairApiNodesKeyPost(sSHKeyPair: SSHKeyPair, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).postSshKeyPairApiNodesKeyPost(sSHKeyPair, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesTaskApi - axios parameter creator
 * @export
 */
export const NodesTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Tasks Nodes Name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksNodesNameApiTasksNodesNameDelete: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteTasksNodesNameApiTasksNodesNameDelete', 'name', name)
            const localVarPath = `/api/tasks/nodes/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Node Role
         * @param {NodeRolePatch} nodeRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNodeRoleApiTasksNodesRolesPatch: async (nodeRolePatch: NodeRolePatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeRolePatch' is not null or undefined
            assertParamExists('patchApiNodeRoleApiTasksNodesRolesPatch', 'nodeRolePatch', nodeRolePatch)
            const localVarPath = `/api/tasks/nodes/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeRolePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Tasks Nodes
         * @param {NodeInsert} [nodeInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksNodesApiTasksNodesPost: async (nodeInsert?: NodeInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesTaskApi - functional programming interface
 * @export
 */
export const NodesTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Tasks Nodes Name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTasksNodesNameApiTasksNodesNameDelete(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTasksNodesNameApiTasksNodesNameDelete(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Node Role
         * @param {NodeRolePatch} nodeRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiNodeRoleApiTasksNodesRolesPatch(nodeRolePatch: NodeRolePatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiNodeRoleApiTasksNodesRolesPatch(nodeRolePatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Tasks Nodes
         * @param {NodeInsert} [nodeInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTasksNodesApiTasksNodesPost(nodeInsert?: NodeInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTasksNodesApiTasksNodesPost(nodeInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesTaskApi - factory interface
 * @export
 */
export const NodesTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesTaskApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Tasks Nodes Name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksNodesNameApiTasksNodesNameDelete(name: string, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.deleteTasksNodesNameApiTasksNodesNameDelete(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Node Role
         * @param {NodeRolePatch} nodeRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNodeRoleApiTasksNodesRolesPatch(nodeRolePatch: NodeRolePatch, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.patchApiNodeRoleApiTasksNodesRolesPatch(nodeRolePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Tasks Nodes
         * @param {NodeInsert} [nodeInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTasksNodesApiTasksNodesPost(nodeInsert?: NodeInsert, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.postTasksNodesApiTasksNodesPost(nodeInsert, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesTaskApi - object-oriented interface
 * @export
 * @class NodesTaskApi
 * @extends {BaseAPI}
 */
export class NodesTaskApi extends BaseAPI {
    /**
     * 
     * @summary Delete Tasks Nodes Name
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesTaskApi
     */
    public deleteTasksNodesNameApiTasksNodesNameDelete(name: string, options?: AxiosRequestConfig) {
        return NodesTaskApiFp(this.configuration).deleteTasksNodesNameApiTasksNodesNameDelete(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Node Role
     * @param {NodeRolePatch} nodeRolePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesTaskApi
     */
    public patchApiNodeRoleApiTasksNodesRolesPatch(nodeRolePatch: NodeRolePatch, options?: AxiosRequestConfig) {
        return NodesTaskApiFp(this.configuration).patchApiNodeRoleApiTasksNodesRolesPatch(nodeRolePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Tasks Nodes
     * @param {NodeInsert} [nodeInsert] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesTaskApi
     */
    public postTasksNodesApiTasksNodesPost(nodeInsert?: NodeInsert, options?: AxiosRequestConfig) {
        return NodesTaskApiFp(this.configuration).postTasksNodesApiTasksNodesPost(nodeInsert, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Api Projects
         * @param {DeleteProject} deleteProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiProjectsApiProjectsDelete: async (deleteProject: DeleteProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteProject' is not null or undefined
            assertParamExists('deleteApiProjectsApiProjectsDelete', 'deleteProject', deleteProject)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Projects
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiProjectsApiProjectsGet: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Projects
         * @param {PostProject} postProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiProjectsApiProjectsPost: async (postProject: PostProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postProject' is not null or undefined
            assertParamExists('postApiProjectsApiProjectsPost', 'postProject', postProject)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Projects
         * @param {ProjectPatch} projectPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiProjectsApiProjectsPut: async (projectPatch: ProjectPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectPatch' is not null or undefined
            assertParamExists('putApiProjectsApiProjectsPut', 'projectPatch', projectPatch)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Api Projects
         * @param {DeleteProject} deleteProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiProjectsApiProjectsDelete(deleteProject: DeleteProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiProjectsApiProjectsDelete(deleteProject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Projects
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiProjectsApiProjectsGet(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiProjectsApiProjectsGet(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Projects
         * @param {PostProject} postProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiProjectsApiProjectsPost(postProject: PostProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiProjectsApiProjectsPost(postProject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Projects
         * @param {ProjectPatch} projectPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putApiProjectsApiProjectsPut(projectPatch: ProjectPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putApiProjectsApiProjectsPut(projectPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Api Projects
         * @param {DeleteProject} deleteProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiProjectsApiProjectsDelete(deleteProject: DeleteProject, options?: any): AxiosPromise<any> {
            return localVarFp.deleteApiProjectsApiProjectsDelete(deleteProject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Projects
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiProjectsApiProjectsGet(admin?: boolean, options?: any): AxiosPromise<Array<ProjectSelect>> {
            return localVarFp.getApiProjectsApiProjectsGet(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Projects
         * @param {PostProject} postProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiProjectsApiProjectsPost(postProject: PostProject, options?: any): AxiosPromise<any> {
            return localVarFp.postApiProjectsApiProjectsPost(postProject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Projects
         * @param {ProjectPatch} projectPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiProjectsApiProjectsPut(projectPatch: ProjectPatch, options?: any): AxiosPromise<any> {
            return localVarFp.putApiProjectsApiProjectsPut(projectPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Api Projects
     * @param {DeleteProject} deleteProject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteApiProjectsApiProjectsDelete(deleteProject: DeleteProject, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteApiProjectsApiProjectsDelete(deleteProject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Projects
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getApiProjectsApiProjectsGet(admin?: boolean, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getApiProjectsApiProjectsGet(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Projects
     * @param {PostProject} postProject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public postApiProjectsApiProjectsPost(postProject: PostProject, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).postApiProjectsApiProjectsPost(postProject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Projects
     * @param {ProjectPatch} projectPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public putApiProjectsApiProjectsPut(projectPatch: ProjectPatch, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).putApiProjectsApiProjectsPut(projectPatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoragesApi - axios parameter creator
 * @export
 */
export const StoragesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Storages
         * @param {string} [name] 
         * @param {string} [nodeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesApiStoragesGet: async (name?: string, nodeName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nodeName !== undefined) {
                localVarQueryParameter['nodeName'] = nodeName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Storages Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesPoolsApiStoragesPoolsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Storages Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesUuidApiStoragesUuidGet: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getApiStoragesUuidApiStoragesUuidGet', 'uuid', uuid)
            const localVarPath = `/api/storages/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageMetadataPatch} [storageMetadataPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiStoragesPatch: async (storageMetadataPatch?: StorageMetadataPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageMetadataPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PatchStoragePool} patchStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStoragesPoolsApiStoragesPoolsPatch: async (patchStoragePool: PatchStoragePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchStoragePool' is not null or undefined
            assertParamExists('postApiStoragesPoolsApiStoragesPoolsPatch', 'patchStoragePool', patchStoragePool)
            const localVarPath = `/api/storages/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchStoragePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PostStoragePool} postStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStoragesPoolsApiStoragesPoolsPost: async (postStoragePool: PostStoragePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postStoragePool' is not null or undefined
            assertParamExists('postApiStoragesPoolsApiStoragesPoolsPost', 'postStoragePool', postStoragePool)
            const localVarPath = `/api/storages/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postStoragePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoragesApi - functional programming interface
 * @export
 */
export const StoragesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoragesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Storages
         * @param {string} [name] 
         * @param {string} [nodeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiStoragesApiStoragesGet(name?: string, nodeName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiStoragesApiStoragesGet(name, nodeName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Storages Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiStoragesPoolsApiStoragesPoolsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetStoragePool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiStoragesPoolsApiStoragesPoolsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Storages Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiStoragesUuidApiStoragesUuidGet(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiStoragesUuidApiStoragesUuidGet(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageMetadataPatch} [storageMetadataPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStorageApiStoragesPatch(storageMetadataPatch?: StorageMetadataPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStorageApiStoragesPatch(storageMetadataPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PatchStoragePool} patchStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool: PatchStoragePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PostStoragePool} postStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool: PostStoragePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoragesApi - factory interface
 * @export
 */
export const StoragesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoragesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Storages
         * @param {string} [name] 
         * @param {string} [nodeName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesApiStoragesGet(name?: string, nodeName?: string, options?: any): AxiosPromise<Array<StorageSelect>> {
            return localVarFp.getApiStoragesApiStoragesGet(name, nodeName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Storages Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesPoolsApiStoragesPoolsGet(options?: any): AxiosPromise<Array<GetStoragePool>> {
            return localVarFp.getApiStoragesPoolsApiStoragesPoolsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Storages Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesUuidApiStoragesUuidGet(uuid: string, options?: any): AxiosPromise<StorageSelect> {
            return localVarFp.getApiStoragesUuidApiStoragesUuidGet(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageMetadataPatch} [storageMetadataPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiStoragesPatch(storageMetadataPatch?: StorageMetadataPatch, options?: any): AxiosPromise<any> {
            return localVarFp.postApiStorageApiStoragesPatch(storageMetadataPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PatchStoragePool} patchStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool: PatchStoragePool, options?: any): AxiosPromise<any> {
            return localVarFp.postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PostStoragePool} postStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool: PostStoragePool, options?: any): AxiosPromise<any> {
            return localVarFp.postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoragesApi - object-oriented interface
 * @export
 * @class StoragesApi
 * @extends {BaseAPI}
 */
export class StoragesApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Storages
     * @param {string} [name] 
     * @param {string} [nodeName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public getApiStoragesApiStoragesGet(name?: string, nodeName?: string, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).getApiStoragesApiStoragesGet(name, nodeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Storages Pools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public getApiStoragesPoolsApiStoragesPoolsGet(options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).getApiStoragesPoolsApiStoragesPoolsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Storages Uuid
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public getApiStoragesUuidApiStoragesUuidGet(uuid: string, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).getApiStoragesUuidApiStoragesUuidGet(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storage
     * @param {StorageMetadataPatch} [storageMetadataPatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public postApiStorageApiStoragesPatch(storageMetadataPatch?: StorageMetadataPatch, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).postApiStorageApiStoragesPatch(storageMetadataPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storages Pools
     * @param {PatchStoragePool} patchStoragePool 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool: PatchStoragePool, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storages Pools
     * @param {PostStoragePool} postStoragePool 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesApi
     */
    public postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool: PostStoragePool, options?: AxiosRequestConfig) {
        return StoragesApiFp(this.configuration).postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoragesTaskApi - axios parameter creator
 * @export
 */
export const StoragesTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Api Storages
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiStoragesApiTasksStoragesUuidDelete: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteApiStoragesApiTasksStoragesUuidDelete', 'uuid', uuid)
            const localVarPath = `/api/tasks/storages/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageInsert} [storageInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiTasksStoragesPost: async (storageInsert?: StorageInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoragesTaskApi - functional programming interface
 * @export
 */
export const StoragesTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoragesTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Api Storages
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiStoragesApiTasksStoragesUuidDelete(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiStoragesApiTasksStoragesUuidDelete(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageInsert} [storageInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStorageApiTasksStoragesPost(storageInsert?: StorageInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStorageApiTasksStoragesPost(storageInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoragesTaskApi - factory interface
 * @export
 */
export const StoragesTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoragesTaskApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Api Storages
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiStoragesApiTasksStoragesUuidDelete(uuid: string, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.deleteApiStoragesApiTasksStoragesUuidDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageInsert} [storageInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiTasksStoragesPost(storageInsert?: StorageInsert, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.postApiStorageApiTasksStoragesPost(storageInsert, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoragesTaskApi - object-oriented interface
 * @export
 * @class StoragesTaskApi
 * @extends {BaseAPI}
 */
export class StoragesTaskApi extends BaseAPI {
    /**
     * 
     * @summary Delete Api Storages
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesTaskApi
     */
    public deleteApiStoragesApiTasksStoragesUuidDelete(uuid: string, options?: AxiosRequestConfig) {
        return StoragesTaskApiFp(this.configuration).deleteApiStoragesApiTasksStoragesUuidDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storage
     * @param {StorageInsert} [storageInsert] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesTaskApi
     */
    public postApiStorageApiTasksStoragesPost(storageInsert?: StorageInsert, options?: AxiosRequestConfig) {
        return StoragesTaskApiFp(this.configuration).postApiStorageApiTasksStoragesPost(storageInsert, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksApiTasksDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tasks
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [resource] 
         * @param {string} [object] 
         * @param {string} [method] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksApiTasksGet: async (admin?: boolean, limit?: number, page?: number, resource?: string, object?: string, method?: string, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tasks
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksApiTasksUuidGet: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getTasksApiTasksUuidGet', 'uuid', uuid)
            const localVarPath = `/api/tasks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tasks Incomplete
         * @param {string} [hash] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIncompleteApiTasksIncompleteGet: async (hash?: string, admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/incomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTasksApiTasksDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTasksApiTasksDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tasks
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [resource] 
         * @param {string} [object] 
         * @param {string} [method] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasksApiTasksGet(admin?: boolean, limit?: number, page?: number, resource?: string, object?: string, method?: string, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskPagesnation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasksApiTasksGet(admin, limit, page, resource, object, method, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tasks
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasksApiTasksUuidGet(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasksApiTasksUuidGet(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tasks Incomplete
         * @param {string} [hash] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasksIncompleteApiTasksIncompleteGet(hash?: string, admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskIncomplete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasksIncompleteApiTasksIncompleteGet(hash, admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksApiTasksDelete(options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.deleteTasksApiTasksDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tasks
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [resource] 
         * @param {string} [object] 
         * @param {string} [method] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksApiTasksGet(admin?: boolean, limit?: number, page?: number, resource?: string, object?: string, method?: string, status?: string, options?: any): AxiosPromise<TaskPagesnation> {
            return localVarFp.getTasksApiTasksGet(admin, limit, page, resource, object, method, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tasks
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksApiTasksUuidGet(uuid: string, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.getTasksApiTasksUuidGet(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tasks Incomplete
         * @param {string} [hash] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIncompleteApiTasksIncompleteGet(hash?: string, admin?: boolean, options?: any): AxiosPromise<TaskIncomplete> {
            return localVarFp.getTasksIncompleteApiTasksIncompleteGet(hash, admin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary Delete Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTasksApiTasksDelete(options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).deleteTasksApiTasksDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tasks
     * @param {boolean} [admin] 
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {string} [resource] 
     * @param {string} [object] 
     * @param {string} [method] 
     * @param {string} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksApiTasksGet(admin?: boolean, limit?: number, page?: number, resource?: string, object?: string, method?: string, status?: string, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTasksApiTasksGet(admin, limit, page, resource, object, method, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tasks
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksApiTasksUuidGet(uuid: string, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTasksApiTasksUuidGet(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tasks Incomplete
     * @param {string} [hash] 
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksIncompleteApiTasksIncompleteGet(hash?: string, admin?: boolean, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTasksIncompleteApiTasksIncompleteGet(hash, admin, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiUsersApiUsersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Users
         * @param {UserInsert} userInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiUsersApiUsersPost: async (userInsert: UserInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInsert' is not null or undefined
            assertParamExists('postApiUsersApiUsersPost', 'userInsert', userInsert)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersMeApiUsersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiUsersApiUsersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUsers>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiUsersApiUsersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Users
         * @param {UserInsert} userInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiUsersApiUsersPost(userInsert: UserInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiUsersApiUsersPost(userInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsersMeApiUsersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsersMeApiUsersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiUsersApiUsersGet(options?: any): AxiosPromise<Array<GetUsers>> {
            return localVarFp.getApiUsersApiUsersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Users
         * @param {UserInsert} userInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiUsersApiUsersPost(userInsert: UserInsert, options?: any): AxiosPromise<any> {
            return localVarFp.postApiUsersApiUsersPost(userInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersMeApiUsersMeGet(options?: any): AxiosPromise<TokenData> {
            return localVarFp.readUsersMeApiUsersMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getApiUsersApiUsersGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getApiUsersApiUsersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Users
     * @param {UserInsert} userInsert 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postApiUsersApiUsersPost(userInsert: UserInsert, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).postApiUsersApiUsersPost(userInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Users Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUsersMeApiUsersMeGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).readUsersMeApiUsersMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VmsApi - axios parameter creator
 * @export
 */
export const VmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Domain
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [nameLike] 
         * @param {string} [nodeNameLike] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainApiVmsGet: async (admin?: boolean, limit?: number, page?: number, nameLike?: string, nodeNameLike?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['name_like'] = nameLike;
            }

            if (nodeNameLike !== undefined) {
                localVarQueryParameter['node_name_like'] = nodeNameLike;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainApiVmsVncTokenGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getApiDomainApiVmsVncTokenGet', 'token', token)
            const localVarPath = `/api/vms/vnc/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Domain Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainUuidApiVmsUuidGet: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getApiDomainUuidApiVmsUuidGet', 'uuid', uuid)
            const localVarPath = `/api/vms/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VmsApi - functional programming interface
 * @export
 */
export const VmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Domain
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [nameLike] 
         * @param {string} [nodeNameLike] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiDomainApiVmsGet(admin?: boolean, limit?: number, page?: number, nameLike?: string, nodeNameLike?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainPagenation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiDomainApiVmsGet(admin, limit, page, nameLike, nodeNameLike, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiDomainApiVmsVncTokenGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiDomainApiVmsVncTokenGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Domain Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiDomainUuidApiVmsUuidGet(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiDomainUuidApiVmsUuidGet(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VmsApi - factory interface
 * @export
 */
export const VmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VmsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Domain
         * @param {boolean} [admin] 
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {string} [nameLike] 
         * @param {string} [nodeNameLike] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainApiVmsGet(admin?: boolean, limit?: number, page?: number, nameLike?: string, nodeNameLike?: string, options?: any): AxiosPromise<GetDomainPagenation> {
            return localVarFp.getApiDomainApiVmsGet(admin, limit, page, nameLike, nodeNameLike, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainApiVmsVncTokenGet(token: string, options?: any): AxiosPromise<any> {
            return localVarFp.getApiDomainApiVmsVncTokenGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Domain Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainUuidApiVmsUuidGet(uuid: string, options?: any): AxiosPromise<GetDomainDetail> {
            return localVarFp.getApiDomainUuidApiVmsUuidGet(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VmsApi - object-oriented interface
 * @export
 * @class VmsApi
 * @extends {BaseAPI}
 */
export class VmsApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Domain
     * @param {boolean} [admin] 
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {string} [nameLike] 
     * @param {string} [nodeNameLike] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public getApiDomainApiVmsGet(admin?: boolean, limit?: number, page?: number, nameLike?: string, nodeNameLike?: string, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).getApiDomainApiVmsGet(admin, limit, page, nameLike, nodeNameLike, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Domain
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public getApiDomainApiVmsVncTokenGet(token: string, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).getApiDomainApiVmsVncTokenGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Domain Uuid
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public getApiDomainUuidApiVmsUuidGet(uuid: string, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).getApiDomainUuidApiVmsUuidGet(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VmsTaskApi - axios parameter creator
 * @export
 */
export const VmsTaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Api Domains
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiDomainsApiTasksVmsUuidDelete: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteApiDomainsApiTasksVmsUuidDelete', 'uuid', uuid)
            const localVarPath = `/api/tasks/vms/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * umount - path = null  mount - path = iso file path
         * @summary Patch Api Tasks Vms Uuid Cdrom
         * @param {string} uuid 
         * @param {PatchDominCdrom} [patchDominCdrom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiTasksVmsUuidCdromApiTasksVmsUuidCdromPatch: async (uuid: string, patchDominCdrom?: PatchDominCdrom, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('patchApiTasksVmsUuidCdromApiTasksVmsUuidCdromPatch', 'uuid', uuid)
            const localVarPath = `/api/tasks/vms/{uuid}/cdrom`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchDominCdrom, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Tasks Vms Uuid Power
         * @param {string} uuid 
         * @param {PatchDomainPower} [patchDomainPower] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiTasksVmsUuidPowerApiTasksVmsUuidPowerPatch: async (uuid: string, patchDomainPower?: PatchDomainPower, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('patchApiTasksVmsUuidPowerApiTasksVmsUuidPowerPatch', 'uuid', uuid)
            const localVarPath = `/api/tasks/vms/{uuid}/power`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchDomainPower, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Power off required**  Exception: Cannot switch the OVS while the VM is runningOperation not supported: unable to change config on \'network\' network type
         * @summary Patch Api Vm Network
         * @param {string} uuid 
         * @param {DomainNetworkChange} [domainNetworkChange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiVmNetworkApiTasksVmsUuidNetworkPatch: async (uuid: string, domainNetworkChange?: DomainNetworkChange, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('patchApiVmNetworkApiTasksVmsUuidNetworkPatch', 'uuid', uuid)
            const localVarPath = `/api/tasks/vms/{uuid}/network`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainNetworkChange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {DomainInsert} [domainInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiVmsApiTasksVmsPost: async (domainInsert?: DomainInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish Task To Update Vm List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishTaskToUpdateVmListApiTasksVmsPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VmsTaskApi - functional programming interface
 * @export
 */
export const VmsTaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VmsTaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Api Domains
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiDomainsApiTasksVmsUuidDelete(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiDomainsApiTasksVmsUuidDelete(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * umount - path = null  mount - path = iso file path
         * @summary Patch Api Tasks Vms Uuid Cdrom
         * @param {string} uuid 
         * @param {PatchDominCdrom} [patchDominCdrom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiTasksVmsUuidCdromApiTasksVmsUuidCdromPatch(uuid: string, patchDominCdrom?: PatchDominCdrom, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiTasksVmsUuidCdromApiTasksVmsUuidCdromPatch(uuid, patchDominCdrom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Tasks Vms Uuid Power
         * @param {string} uuid 
         * @param {PatchDomainPower} [patchDomainPower] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiTasksVmsUuidPowerApiTasksVmsUuidPowerPatch(uuid: string, patchDomainPower?: PatchDomainPower, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiTasksVmsUuidPowerApiTasksVmsUuidPowerPatch(uuid, patchDomainPower, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Power off required**  Exception: Cannot switch the OVS while the VM is runningOperation not supported: unable to change config on \'network\' network type
         * @summary Patch Api Vm Network
         * @param {string} uuid 
         * @param {DomainNetworkChange} [domainNetworkChange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiVmNetworkApiTasksVmsUuidNetworkPatch(uuid: string, domainNetworkChange?: DomainNetworkChange, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiVmNetworkApiTasksVmsUuidNetworkPatch(uuid, domainNetworkChange, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {DomainInsert} [domainInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiVmsApiTasksVmsPost(domainInsert?: DomainInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiVmsApiTasksVmsPost(domainInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish Task To Update Vm List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishTaskToUpdateVmListApiTasksVmsPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishTaskToUpdateVmListApiTasksVmsPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VmsTaskApi - factory interface
 * @export
 */
export const VmsTaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VmsTaskApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Api Domains
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiDomainsApiTasksVmsUuidDelete(uuid: string, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.deleteApiDomainsApiTasksVmsUuidDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * umount - path = null  mount - path = iso file path
         * @summary Patch Api Tasks Vms Uuid Cdrom
         * @param {string} uuid 
         * @param {PatchDominCdrom} [patchDominCdrom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiTasksVmsUuidCdromApiTasksVmsUuidCdromPatch(uuid: string, patchDominCdrom?: PatchDominCdrom, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.patchApiTasksVmsUuidCdromApiTasksVmsUuidCdromPatch(uuid, patchDominCdrom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Tasks Vms Uuid Power
         * @param {string} uuid 
         * @param {PatchDomainPower} [patchDomainPower] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiTasksVmsUuidPowerApiTasksVmsUuidPowerPatch(uuid: string, patchDomainPower?: PatchDomainPower, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.patchApiTasksVmsUuidPowerApiTasksVmsUuidPowerPatch(uuid, patchDomainPower, options).then((request) => request(axios, basePath));
        },
        /**
         * **Power off required**  Exception: Cannot switch the OVS while the VM is runningOperation not supported: unable to change config on \'network\' network type
         * @summary Patch Api Vm Network
         * @param {string} uuid 
         * @param {DomainNetworkChange} [domainNetworkChange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiVmNetworkApiTasksVmsUuidNetworkPatch(uuid: string, domainNetworkChange?: DomainNetworkChange, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.patchApiVmNetworkApiTasksVmsUuidNetworkPatch(uuid, domainNetworkChange, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {DomainInsert} [domainInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiVmsApiTasksVmsPost(domainInsert?: DomainInsert, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.postApiVmsApiTasksVmsPost(domainInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish Task To Update Vm List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishTaskToUpdateVmListApiTasksVmsPut(options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.publishTaskToUpdateVmListApiTasksVmsPut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VmsTaskApi - object-oriented interface
 * @export
 * @class VmsTaskApi
 * @extends {BaseAPI}
 */
export class VmsTaskApi extends BaseAPI {
    /**
     * 
     * @summary Delete Api Domains
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public deleteApiDomainsApiTasksVmsUuidDelete(uuid: string, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).deleteApiDomainsApiTasksVmsUuidDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * umount - path = null  mount - path = iso file path
     * @summary Patch Api Tasks Vms Uuid Cdrom
     * @param {string} uuid 
     * @param {PatchDominCdrom} [patchDominCdrom] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public patchApiTasksVmsUuidCdromApiTasksVmsUuidCdromPatch(uuid: string, patchDominCdrom?: PatchDominCdrom, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).patchApiTasksVmsUuidCdromApiTasksVmsUuidCdromPatch(uuid, patchDominCdrom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Tasks Vms Uuid Power
     * @param {string} uuid 
     * @param {PatchDomainPower} [patchDomainPower] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public patchApiTasksVmsUuidPowerApiTasksVmsUuidPowerPatch(uuid: string, patchDomainPower?: PatchDomainPower, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).patchApiTasksVmsUuidPowerApiTasksVmsUuidPowerPatch(uuid, patchDomainPower, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Power off required**  Exception: Cannot switch the OVS while the VM is runningOperation not supported: unable to change config on \'network\' network type
     * @summary Patch Api Vm Network
     * @param {string} uuid 
     * @param {DomainNetworkChange} [domainNetworkChange] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public patchApiVmNetworkApiTasksVmsUuidNetworkPatch(uuid: string, domainNetworkChange?: DomainNetworkChange, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).patchApiVmNetworkApiTasksVmsUuidNetworkPatch(uuid, domainNetworkChange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Vms
     * @param {DomainInsert} [domainInsert] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public postApiVmsApiTasksVmsPost(domainInsert?: DomainInsert, options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).postApiVmsApiTasksVmsPost(domainInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish Task To Update Vm List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsTaskApi
     */
    public publishTaskToUpdateVmListApiTasksVmsPut(options?: AxiosRequestConfig) {
        return VmsTaskApiFp(this.configuration).publishTaskToUpdateVmListApiTasksVmsPut(options).then((request) => request(this.axios, this.basePath));
    }
}


