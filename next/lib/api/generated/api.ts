/* tslint:disable */
/* eslint-disable */
/**
 * VirtyAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CloudInitInsert
 */
export interface CloudInitInsert {
    /**
     * 
     * @type {string}
     * @memberof CloudInitInsert
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof CloudInitInsert
     */
    'userData': string;
}
/**
 * 
 * @export
 * @interface DeleteProject
 */
export interface DeleteProject {
    /**
     * 
     * @type {string}
     * @memberof DeleteProject
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DomainDelete
 */
export interface DomainDelete {
    /**
     * 
     * @type {string}
     * @memberof DomainDelete
     */
    'uuid': string;
}
/**
 * 
 * @export
 * @interface DomainInsert
 */
export interface DomainInsert {
    /**
     * 
     * @type {string}
     * @memberof DomainInsert
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsert
     */
    'nodeName': string;
    /**
     * 
     * @type {number}
     * @memberof DomainInsert
     */
    'memoryMegaByte': number;
    /**
     * 
     * @type {number}
     * @memberof DomainInsert
     */
    'cpu': number;
    /**
     * 
     * @type {Array<DomainInsertDisk>}
     * @memberof DomainInsert
     */
    'disks': Array<DomainInsertDisk>;
    /**
     * 
     * @type {Array<DomainInsertInterface>}
     * @memberof DomainInsert
     */
    'interface': Array<DomainInsertInterface>;
    /**
     * 
     * @type {CloudInitInsert}
     * @memberof DomainInsert
     */
    'cloudInit'?: CloudInitInsert;
}
/**
 * 
 * @export
 * @interface DomainInsertDisk
 */
export interface DomainInsertDisk {
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'savePoolUuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'originalPoolUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'originalName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DomainInsertDisk
     */
    'sizeGigaByte'?: number;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertDisk
     */
    'templateName'?: string;
}
/**
 * 
 * @export
 * @interface DomainInsertInterface
 */
export interface DomainInsertInterface {
    /**
     * 
     * @type {string}
     * @memberof DomainInsertInterface
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertInterface
     */
    'mac'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertInterface
     */
    'networkName': string;
    /**
     * 
     * @type {string}
     * @memberof DomainInsertInterface
     */
    'port'?: string;
}
/**
 * 
 * @export
 * @interface DomainNetworkChange
 */
export interface DomainNetworkChange {
    /**
     * 
     * @type {string}
     * @memberof DomainNetworkChange
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainNetworkChange
     */
    'mac': string;
    /**
     * 
     * @type {string}
     * @memberof DomainNetworkChange
     */
    'networkName': string;
    /**
     * 
     * @type {string}
     * @memberof DomainNetworkChange
     */
    'port'?: string;
}
/**
 * 
 * @export
 * @interface DomainPatch
 */
export interface DomainPatch {
    /**
     * 
     * @type {string}
     * @memberof DomainPatch
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainPatch
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainPatch
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainPatch
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface DomainPatchCore
 */
export interface DomainPatchCore {
    /**
     * 
     * @type {string}
     * @memberof DomainPatchCore
     */
    'uuid': string;
    /**
     * 
     * @type {number}
     * @memberof DomainPatchCore
     */
    'core': number;
}
/**
 * 
 * @export
 * @interface DomainPatchName
 */
export interface DomainPatchName {
    /**
     * 
     * @type {string}
     * @memberof DomainPatchName
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainPatchName
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface DomainPatchUser
 */
export interface DomainPatchUser {
    /**
     * 
     * @type {string}
     * @memberof DomainPatchUser
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainPatchUser
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface DomainProjectPatch
 */
export interface DomainProjectPatch {
    /**
     * 
     * @type {string}
     * @memberof DomainProjectPatch
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof DomainProjectPatch
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface GetDomain
 */
export interface GetDomain {
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GetDomain
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof GetDomain
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof GetDomain
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'ownerGroupId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetDomain
     */
    'vncPort'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDomain
     */
    'vncPassword'?: string;
    /**
     * 
     * @type {Array<GetDomainDrives>}
     * @memberof GetDomain
     */
    'drives'?: Array<GetDomainDrives>;
    /**
     * 
     * @type {Array<GetDomainInterfaces>}
     * @memberof GetDomain
     */
    'interfaces'?: Array<GetDomainInterfaces>;
}
/**
 * 
 * @export
 * @interface GetDomainDetail
 */
export interface GetDomainDetail {
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GetDomainDetail
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof GetDomainDetail
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof GetDomainDetail
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'ownerGroupId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetDomainDetail
     */
    'vncPort'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDetail
     */
    'vncPassword'?: string;
    /**
     * 
     * @type {Array<GetDomainDrives>}
     * @memberof GetDomainDetail
     */
    'drives'?: Array<GetDomainDrives>;
    /**
     * 
     * @type {Array<GetDomainInterfaces>}
     * @memberof GetDomainDetail
     */
    'interfaces'?: Array<GetDomainInterfaces>;
    /**
     * 
     * @type {GetNode}
     * @memberof GetDomainDetail
     */
    'node': GetNode;
}
/**
 * 
 * @export
 * @interface GetDomainDrives
 */
export interface GetDomainDrives {
    /**
     * 
     * @type {string}
     * @memberof GetDomainDrives
     */
    'device'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDrives
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDrives
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainDrives
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface GetDomainInterfaces
 */
export interface GetDomainInterfaces {
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'mac'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'bridge'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDomainInterfaces
     */
    'port'?: string;
}
/**
 * 
 * @export
 * @interface GetFlavor
 */
export interface GetFlavor {
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'os': string;
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'manualUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetFlavor
     */
    'cloudInitReady': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetFlavor
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof GetFlavor
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface GetImageDomain
 */
export interface GetImageDomain {
    /**
     * 
     * @type {string}
     * @memberof GetImageDomain
     */
    'ownerUserId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetImageDomain
     */
    'issuanceId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetImageDomain
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetImageDomain
     */
    'uuid': string;
}
/**
 * 
 * @export
 * @interface GetIssuance
 */
export interface GetIssuance {
    /**
     * 
     * @type {string}
     * @memberof GetIssuance
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof GetIssuance
     */
    'ticketId': string;
    /**
     * 
     * @type {number}
     * @memberof GetIssuance
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetIssuance
     */
    'issuedBy': string;
    /**
     * 
     * @type {string}
     * @memberof GetIssuance
     */
    'issuedDate': string;
    /**
     * 
     * @type {GetTicket}
     * @memberof GetIssuance
     */
    'ticket': GetTicket;
}
/**
 * 
 * @export
 * @interface GetNEtworkPoolNetworksNetwork
 */
export interface GetNEtworkPoolNetworksNetwork {
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'bridge': string;
    /**
     * 
     * @type {string}
     * @memberof GetNEtworkPoolNetworksNetwork
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface GetNetwork
 */
export interface GetNetwork {
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetNetwork
     */
    'dhcp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetNetwork
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'bridge'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetNetwork
     */
    'autoStart'?: boolean;
    /**
     * 
     * @type {Array<NetworkPortgroup>}
     * @memberof GetNetwork
     */
    'portgroups': Array<NetworkPortgroup>;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetwork
     */
    'updateToken'?: string;
}
/**
 * 
 * @export
 * @interface GetNetworkPool
 */
export interface GetNetworkPool {
    /**
     * 
     * @type {number}
     * @memberof GetNetworkPool
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkPool
     */
    'name'?: string;
    /**
     * 
     * @type {Array<GetNEtworkPoolNetworksNetwork>}
     * @memberof GetNetworkPool
     */
    'networks'?: Array<GetNEtworkPoolNetworksNetwork>;
    /**
     * 
     * @type {Array<GetNetworkPoolPort>}
     * @memberof GetNetworkPool
     */
    'ports'?: Array<GetNetworkPoolPort>;
}
/**
 * 
 * @export
 * @interface GetNetworkPoolPort
 */
export interface GetNetworkPoolPort {
    /**
     * 
     * @type {string}
     * @memberof GetNetworkPoolPort
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetNetworkPoolPort
     */
    'vlanId'?: number;
    /**
     * 
     * @type {GetNEtworkPoolNetworksNetwork}
     * @memberof GetNetworkPoolPort
     */
    'network': GetNEtworkPoolNetworksNetwork;
}
/**
 * 
 * @export
 * @interface GetNode
 */
export interface GetNode {
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'userName': string;
    /**
     * 
     * @type {number}
     * @memberof GetNode
     */
    'port': number;
    /**
     * 
     * @type {number}
     * @memberof GetNode
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof GetNode
     */
    'memory': number;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'cpuGen': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'osLike': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'osName': string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'osVersion': string;
    /**
     * 
     * @type {number}
     * @memberof GetNode
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'qemuVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNode
     */
    'libvirtVersion'?: string;
    /**
     * 
     * @type {Array<GetNodeRole>}
     * @memberof GetNode
     */
    'roles': Array<GetNodeRole>;
}
/**
 * 
 * @export
 * @interface GetNodeRole
 */
export interface GetNodeRole {
    /**
     * 
     * @type {string}
     * @memberof GetNodeRole
     */
    'roleName': string;
    /**
     * 
     * @type {object}
     * @memberof GetNodeRole
     */
    'extraJson'?: object;
}
/**
 * 
 * @export
 * @interface GetStoragePool
 */
export interface GetStoragePool {
    /**
     * 
     * @type {number}
     * @memberof GetStoragePool
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetStoragePool
     */
    'name': string;
    /**
     * 
     * @type {Array<GetStoragePoolStorages>}
     * @memberof GetStoragePool
     */
    'storages': Array<GetStoragePoolStorages>;
}
/**
 * 
 * @export
 * @interface GetStoragePoolStorages
 */
export interface GetStoragePoolStorages {
    /**
     * 
     * @type {GetStoragePoolStoragesStorage}
     * @memberof GetStoragePoolStorages
     */
    'storage': GetStoragePoolStoragesStorage;
}
/**
 * 
 * @export
 * @interface GetStoragePoolStoragesStorage
 */
export interface GetStoragePoolStoragesStorage {
    /**
     * 
     * @type {string}
     * @memberof GetStoragePoolStoragesStorage
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetStoragePoolStoragesStorage
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof GetStoragePoolStoragesStorage
     */
    'nodeName': string;
}
/**
 * 
 * @export
 * @interface GetTicket
 */
export interface GetTicket {
    /**
     * 
     * @type {string}
     * @memberof GetTicket
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GetTicket
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof GetTicket
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof GetTicket
     */
    'storageCapacityG'?: number;
    /**
     * 
     * @type {Array<GetNetworkPool>}
     * @memberof GetTicket
     */
    'networkPools': Array<GetNetworkPool>;
    /**
     * 
     * @type {Array<GetStoragePool>}
     * @memberof GetTicket
     */
    'storagePools': Array<GetStoragePool>;
    /**
     * 
     * @type {Array<GetFlavor>}
     * @memberof GetTicket
     */
    'flavors': Array<GetFlavor>;
    /**
     * 
     * @type {boolean}
     * @memberof GetTicket
     */
    'userInstallable': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetTicket
     */
    'isolatedNetworks': number;
    /**
     * 
     * @type {number}
     * @memberof GetTicket
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface ImageSCP
 */
export interface ImageSCP {
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'fromNodeName': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'toNodeName': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'fromFilePath': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSCP
     */
    'toFilePath': string;
}
/**
 * 
 * @export
 * @interface ImageSelect
 */
export interface ImageSelect {
    /**
     * 
     * @type {string}
     * @memberof ImageSelect
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSelect
     */
    'storageUuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ImageSelect
     */
    'capacity': number;
    /**
     * 
     * @type {StorageSelect}
     * @memberof ImageSelect
     */
    'storage': StorageSelect;
    /**
     * 
     * @type {GetFlavor}
     * @memberof ImageSelect
     */
    'flavor'?: GetFlavor;
    /**
     * 
     * @type {number}
     * @memberof ImageSelect
     */
    'allocation': number;
    /**
     * 
     * @type {string}
     * @memberof ImageSelect
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof ImageSelect
     */
    'updateToken'?: string;
    /**
     * 
     * @type {GetImageDomain}
     * @memberof ImageSelect
     */
    'domain'?: GetImageDomain;
}
/**
 * 
 * @export
 * @interface NetworkDelete
 */
export interface NetworkDelete {
    /**
     * 
     * @type {string}
     * @memberof NetworkDelete
     */
    'uuid': string;
}
/**
 * 
 * @export
 * @interface NetworkInsert
 */
export interface NetworkInsert {
    /**
     * 
     * @type {string}
     * @memberof NetworkInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInsert
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInsert
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInsert
     */
    'bridgeDevice'?: string;
}
/**
 * 
 * @export
 * @interface NetworkOVSAdd
 */
export interface NetworkOVSAdd {
    /**
     * 
     * @type {boolean}
     * @memberof NetworkOVSAdd
     */
    'default': boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkOVSAdd
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkOVSAdd
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof NetworkOVSAdd
     */
    'vlanId'?: number;
}
/**
 * 
 * @export
 * @interface NetworkOVSDelete
 */
export interface NetworkOVSDelete {
    /**
     * 
     * @type {string}
     * @memberof NetworkOVSDelete
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkOVSDelete
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface NetworkPortgroup
 */
export interface NetworkPortgroup {
    /**
     * 
     * @type {string}
     * @memberof NetworkPortgroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkPortgroup
     */
    'vlanId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkPortgroup
     */
    'isDefault': boolean;
}
/**
 * 
 * @export
 * @interface NodeBase
 */
export interface NodeBase {
    /**
     * 
     * @type {string}
     * @memberof NodeBase
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface NodeDelete
 */
export interface NodeDelete {
    /**
     * 
     * @type {string}
     * @memberof NodeDelete
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface NodeInsert
 */
export interface NodeInsert {
    /**
     * 
     * @type {string}
     * @memberof NodeInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NodeInsert
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof NodeInsert
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof NodeInsert
     */
    'userName': string;
    /**
     * 
     * @type {number}
     * @memberof NodeInsert
     */
    'port': number;
    /**
     * 
     * @type {boolean}
     * @memberof NodeInsert
     */
    'libvirtRole': boolean;
}
/**
 * 
 * @export
 * @interface NodeRolePatch
 */
export interface NodeRolePatch {
    /**
     * 
     * @type {string}
     * @memberof NodeRolePatch
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof NodeRolePatch
     */
    'roleName': string;
    /**
     * 
     * @type {object}
     * @memberof NodeRolePatch
     */
    'extraJson'?: object;
}
/**
 * 
 * @export
 * @interface PatchImageFlavor
 */
export interface PatchImageFlavor {
    /**
     * 
     * @type {string}
     * @memberof PatchImageFlavor
     */
    'storageUuid': string;
    /**
     * 
     * @type {string}
     * @memberof PatchImageFlavor
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof PatchImageFlavor
     */
    'nodeName': string;
    /**
     * 
     * @type {number}
     * @memberof PatchImageFlavor
     */
    'flavorId': number;
}
/**
 * 
 * @export
 * @interface PatchNetworkPool
 */
export interface PatchNetworkPool {
    /**
     * 
     * @type {number}
     * @memberof PatchNetworkPool
     */
    'poolId': number;
    /**
     * 
     * @type {string}
     * @memberof PatchNetworkPool
     */
    'networkUuid': string;
    /**
     * 
     * @type {string}
     * @memberof PatchNetworkPool
     */
    'portName'?: string;
}
/**
 * 
 * @export
 * @interface PatchNodePool
 */
export interface PatchNodePool {
    /**
     * 
     * @type {number}
     * @memberof PatchNodePool
     */
    'poolId': number;
    /**
     * 
     * @type {string}
     * @memberof PatchNodePool
     */
    'nodeName': string;
    /**
     * 
     * @type {number}
     * @memberof PatchNodePool
     */
    'core': number;
}
/**
 * 
 * @export
 * @interface PatchStoragePool
 */
export interface PatchStoragePool {
    /**
     * 
     * @type {string}
     * @memberof PatchStoragePool
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchStoragePool
     */
    'storageUuids': Array<string>;
}
/**
 * 
 * @export
 * @interface PostDomainTicket
 */
export interface PostDomainTicket {
    /**
     * 
     * @type {string}
     * @memberof PostDomainTicket
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof PostDomainTicket
     */
    'issuanceId': number;
    /**
     * 
     * @type {string}
     * @memberof PostDomainTicket
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PostDomainTicket
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof PostDomainTicket
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof PostDomainTicket
     */
    'flavorId': number;
    /**
     * 
     * @type {number}
     * @memberof PostDomainTicket
     */
    'flavorSizeG': number;
    /**
     * 
     * @type {number}
     * @memberof PostDomainTicket
     */
    'storagePoolId': number;
    /**
     * 
     * @type {Array<PostDomainTicketInterface>}
     * @memberof PostDomainTicket
     */
    'interfaces': Array<PostDomainTicketInterface>;
    /**
     * 
     * @type {CloudInitInsert}
     * @memberof PostDomainTicket
     */
    'cloudInit'?: CloudInitInsert;
}
/**
 * 
 * @export
 * @interface PostDomainTicketInterface
 */
export interface PostDomainTicketInterface {
    /**
     * 
     * @type {number}
     * @memberof PostDomainTicketInterface
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PostDomainTicketInterface
     */
    'mac'?: string;
}
/**
 * 
 * @export
 * @interface PostFlavor
 */
export interface PostFlavor {
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'os': string;
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'manualUrl': string;
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof PostFlavor
     */
    'cloudInitReady': boolean;
    /**
     * 
     * @type {string}
     * @memberof PostFlavor
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface PostIssuance
 */
export interface PostIssuance {
    /**
     * 
     * @type {string}
     * @memberof PostIssuance
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof PostIssuance
     */
    'ticketId': string;
}
/**
 * 
 * @export
 * @interface PostNetworkPool
 */
export interface PostNetworkPool {
    /**
     * 
     * @type {string}
     * @memberof PostNetworkPool
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PostProject
 */
export interface PostProject {
    /**
     * 
     * @type {string}
     * @memberof PostProject
     */
    'projectName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostProject
     */
    'userIds': Array<string>;
}
/**
 * 
 * @export
 * @interface PostStoragePool
 */
export interface PostStoragePool {
    /**
     * 
     * @type {string}
     * @memberof PostStoragePool
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostStoragePool
     */
    'storageUuids': Array<string>;
}
/**
 * 
 * @export
 * @interface PostTicket
 */
export interface PostTicket {
    /**
     * 
     * @type {string}
     * @memberof PostTicket
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PostTicket
     */
    'core': number;
    /**
     * 
     * @type {number}
     * @memberof PostTicket
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof PostTicket
     */
    'storageCapacityG'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof PostTicket
     */
    'networkPools': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof PostTicket
     */
    'storagePools': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof PostTicket
     */
    'flavors': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof PostTicket
     */
    'userInstallable': boolean;
    /**
     * 
     * @type {number}
     * @memberof PostTicket
     */
    'isolatedNetworks': number;
}
/**
 * 
 * @export
 * @interface ProjectPatch
 */
export interface ProjectPatch {
    /**
     * 
     * @type {string}
     * @memberof ProjectPatch
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPatch
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface ProjectSelect
 */
export interface ProjectSelect {
    /**
     * 
     * @type {string}
     * @memberof ProjectSelect
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectSelect
     */
    'name': string;
    /**
     * 
     * @type {Array<UserBase>}
     * @memberof ProjectSelect
     */
    'users': Array<UserBase>;
}
/**
 * 
 * @export
 * @interface SSHKeyPair
 */
export interface SSHKeyPair {
    /**
     * 
     * @type {string}
     * @memberof SSHKeyPair
     */
    'pub': string;
    /**
     * 
     * @type {string}
     * @memberof SSHKeyPair
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface Setup
 */
export interface Setup {
    /**
     * 
     * @type {string}
     * @memberof Setup
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof Setup
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface StorageDelete
 */
export interface StorageDelete {
    /**
     * 
     * @type {string}
     * @memberof StorageDelete
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof StorageDelete
     */
    'nodeName': string;
}
/**
 * 
 * @export
 * @interface StorageInsert
 */
export interface StorageInsert {
    /**
     * 
     * @type {string}
     * @memberof StorageInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageInsert
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof StorageInsert
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface StorageMetadataPatch
 */
export interface StorageMetadataPatch {
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataPatch
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataPatch
     */
    'rool': string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataPatch
     */
    'protocol': string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataPatch
     */
    'deviceType': string;
}
/**
 * 
 * @export
 * @interface StorageMetadataSelect
 */
export interface StorageMetadataSelect {
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataSelect
     */
    'rool'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataSelect
     */
    'protocol'?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageMetadataSelect
     */
    'deviceType'?: string;
}
/**
 * 
 * @export
 * @interface StorageSelect
 */
export interface StorageSelect {
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'uuid': string;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'status': number;
    /**
     * 
     * @type {boolean}
     * @memberof StorageSelect
     */
    'active': boolean;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'available'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'capacity'?: number;
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'nodeName': string;
    /**
     * 
     * @type {GetNode}
     * @memberof StorageSelect
     */
    'node': GetNode;
    /**
     * 
     * @type {boolean}
     * @memberof StorageSelect
     */
    'autoStart': boolean;
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'path'?: string;
    /**
     * 
     * @type {StorageMetadataSelect}
     * @memberof StorageSelect
     */
    'metaData'?: StorageMetadataSelect;
    /**
     * 
     * @type {string}
     * @memberof StorageSelect
     */
    'updateToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'allocationCommit'?: number;
    /**
     * 
     * @type {number}
     * @memberof StorageSelect
     */
    'capacityCommit'?: number;
}
/**
 * 
 * @export
 * @interface TaskSelect
 */
export interface TaskSelect {
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'postTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskSelect
     */
    'runTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'resource'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'method'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'dependenceUuid'?: string;
    /**
     * 
     * @type {object}
     * @memberof TaskSelect
     */
    'request'?: object;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSelect
     */
    'uuid'?: string;
}
/**
 * 
 * @export
 * @interface TokenRFC6749Response
 */
export interface TokenRFC6749Response {
    /**
     * 
     * @type {string}
     * @memberof TokenRFC6749Response
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRFC6749Response
     */
    'token_type': string;
}
/**
 * 
 * @export
 * @interface UserBase
 */
export interface UserBase {
    /**
     * 
     * @type {string}
     * @memberof UserBase
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserInsert
 */
export interface UserInsert {
    /**
     * 
     * @type {string}
     * @memberof UserInsert
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserInsert
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    'loc': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Api Auth Setup
         * @param {Setup} setup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSetupApiAuthSetupPost: async (setup: Setup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setup' is not null or undefined
            assertParamExists('apiAuthSetupApiAuthSetupPost', 'setup', setup)
            const localVarPath = `/api/auth/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Api Auth Setup
         * @param {Setup} setup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSetupApiAuthSetupPost_1: async (setup: Setup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setup' is not null or undefined
            assertParamExists('apiAuthSetupApiAuthSetupPost_1', 'setup', setup)
            const localVarPath = `/api/auth/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshKeyPairApiAuthKeyGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshKeyPairApiAuthKeyGet_2: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionApiAuthVersionGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiAuthPost: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginForAccessTokenApiAuthPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginForAccessTokenApiAuthPost', 'password', password)
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiAuthPost_3: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginForAccessTokenApiAuthPost_3', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginForAccessTokenApiAuthPost_3', 'password', password)
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Ssh Key Pair
         * @param {SSHKeyPair} sSHKeyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSshKeyPairApiAuthKeyPost: async (sSHKeyPair: SSHKeyPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sSHKeyPair' is not null or undefined
            assertParamExists('postSshKeyPairApiAuthKeyPost', 'sSHKeyPair', sSHKeyPair)
            const localVarPath = `/api/auth/key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sSHKeyPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuthValidateApiAuthValidateGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuthValidateApiAuthValidateGet_4: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", ["user"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Api Auth Setup
         * @param {Setup} setup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthSetupApiAuthSetupPost(setup: Setup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthSetupApiAuthSetupPost(setup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Api Auth Setup
         * @param {Setup} setup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthSetupApiAuthSetupPost_1(setup: Setup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthSetupApiAuthSetupPost_1(setup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSshKeyPairApiAuthKeyGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSshKeyPairApiAuthKeyGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSshKeyPairApiAuthKeyGet_2(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSshKeyPairApiAuthKeyGet_2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersionApiAuthVersionGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersionApiAuthVersionGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginForAccessTokenApiAuthPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRFC6749Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginForAccessTokenApiAuthPost(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginForAccessTokenApiAuthPost_3(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRFC6749Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginForAccessTokenApiAuthPost_3(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Ssh Key Pair
         * @param {SSHKeyPair} sSHKeyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSshKeyPairApiAuthKeyPost(sSHKeyPair: SSHKeyPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSshKeyPairApiAuthKeyPost(sSHKeyPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAuthValidateApiAuthValidateGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAuthValidateApiAuthValidateGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAuthValidateApiAuthValidateGet_4(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAuthValidateApiAuthValidateGet_4(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Api Auth Setup
         * @param {Setup} setup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSetupApiAuthSetupPost(setup: Setup, options?: any): AxiosPromise<any> {
            return localVarFp.apiAuthSetupApiAuthSetupPost(setup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Api Auth Setup
         * @param {Setup} setup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSetupApiAuthSetupPost_1(setup: Setup, options?: any): AxiosPromise<any> {
            return localVarFp.apiAuthSetupApiAuthSetupPost_1(setup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshKeyPairApiAuthKeyGet(options?: any): AxiosPromise<any> {
            return localVarFp.getSshKeyPairApiAuthKeyGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Ssh Key Pair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSshKeyPairApiAuthKeyGet_2(options?: any): AxiosPromise<any> {
            return localVarFp.getSshKeyPairApiAuthKeyGet_2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionApiAuthVersionGet(options?: any): AxiosPromise<any> {
            return localVarFp.getVersionApiAuthVersionGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiAuthPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<TokenRFC6749Response> {
            return localVarFp.loginForAccessTokenApiAuthPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login For Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginForAccessTokenApiAuthPost_3(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<TokenRFC6749Response> {
            return localVarFp.loginForAccessTokenApiAuthPost_3(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Ssh Key Pair
         * @param {SSHKeyPair} sSHKeyPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSshKeyPairApiAuthKeyPost(sSHKeyPair: SSHKeyPair, options?: any): AxiosPromise<any> {
            return localVarFp.postSshKeyPairApiAuthKeyPost(sSHKeyPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuthValidateApiAuthValidateGet(options?: any): AxiosPromise<any> {
            return localVarFp.readAuthValidateApiAuthValidateGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Auth Validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuthValidateApiAuthValidateGet_4(options?: any): AxiosPromise<any> {
            return localVarFp.readAuthValidateApiAuthValidateGet_4(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Api Auth Setup
     * @param {Setup} setup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthSetupApiAuthSetupPost(setup: Setup, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthSetupApiAuthSetupPost(setup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Api Auth Setup
     * @param {Setup} setup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthSetupApiAuthSetupPost_1(setup: Setup, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthSetupApiAuthSetupPost_1(setup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Ssh Key Pair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getSshKeyPairApiAuthKeyGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getSshKeyPairApiAuthKeyGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Ssh Key Pair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getSshKeyPairApiAuthKeyGet_2(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getSshKeyPairApiAuthKeyGet_2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getVersionApiAuthVersionGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getVersionApiAuthVersionGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login For Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginForAccessTokenApiAuthPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginForAccessTokenApiAuthPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login For Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginForAccessTokenApiAuthPost_3(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginForAccessTokenApiAuthPost_3(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Ssh Key Pair
     * @param {SSHKeyPair} sSHKeyPair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postSshKeyPairApiAuthKeyPost(sSHKeyPair: SSHKeyPair, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).postSshKeyPairApiAuthKeyPost(sSHKeyPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Auth Validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public readAuthValidateApiAuthValidateGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).readAuthValidateApiAuthValidateGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Auth Validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public readAuthValidateApiAuthValidateGet_4(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).readAuthValidateApiAuthValidateGet_4(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FlavorsApi - axios parameter creator
 * @export
 */
export const FlavorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiFlavorsApiFlavorsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Flavors
         * @param {PostFlavor} postFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiFlavorsApiFlavorsPost: async (postFlavor: PostFlavor, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postFlavor' is not null or undefined
            assertParamExists('postApiFlavorsApiFlavorsPost', 'postFlavor', postFlavor)
            const localVarPath = `/api/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postFlavor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlavorsApi - functional programming interface
 * @export
 */
export const FlavorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlavorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiFlavorsApiFlavorsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFlavor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiFlavorsApiFlavorsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Flavors
         * @param {PostFlavor} postFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiFlavorsApiFlavorsPost(postFlavor: PostFlavor, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiFlavorsApiFlavorsPost(postFlavor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FlavorsApi - factory interface
 * @export
 */
export const FlavorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlavorsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Flavors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiFlavorsApiFlavorsGet(options?: any): AxiosPromise<Array<GetFlavor>> {
            return localVarFp.getApiFlavorsApiFlavorsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Flavors
         * @param {PostFlavor} postFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiFlavorsApiFlavorsPost(postFlavor: PostFlavor, options?: any): AxiosPromise<any> {
            return localVarFp.postApiFlavorsApiFlavorsPost(postFlavor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlavorsApi - object-oriented interface
 * @export
 * @class FlavorsApi
 * @extends {BaseAPI}
 */
export class FlavorsApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Flavors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public getApiFlavorsApiFlavorsGet(options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).getApiFlavorsApiFlavorsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Flavors
     * @param {PostFlavor} postFlavor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public postApiFlavorsApiFlavorsPost(postFlavor: PostFlavor, options?: AxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).postApiFlavorsApiFlavorsPost(postFlavor, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exporter Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exporterGetApiMetricsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Exporter Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exporterGetApiMetricsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exporterGetApiMetricsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Exporter Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exporterGetApiMetricsGet(options?: any): AxiosPromise<string> {
            return localVarFp.exporterGetApiMetricsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Exporter Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public exporterGetApiMetricsGet(options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).exporterGetApiMetricsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkApi - axios parameter creator
 * @export
 */
export const NetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksApiNetworksGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Networks Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksPoolsApiNetworksPoolsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Networks Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksUuidApiNetworksUuidGet: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getApiNetworksUuidApiNetworksUuidGet', 'uuid', uuid)
            const localVarPath = `/api/networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Networks Pools
         * @param {PatchNetworkPool} patchNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNetworksPoolsApiNetworksPoolsPatch: async (patchNetworkPool: PatchNetworkPool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchNetworkPool' is not null or undefined
            assertParamExists('patchApiNetworksPoolsApiNetworksPoolsPatch', 'patchNetworkPool', patchNetworkPool)
            const localVarPath = `/api/networks/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchNetworkPool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Networks Pools
         * @param {PostNetworkPool} postNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksPoolsApiNetworksPoolsPost: async (postNetworkPool: PostNetworkPool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postNetworkPool' is not null or undefined
            assertParamExists('postApiNetworksPoolsApiNetworksPoolsPost', 'postNetworkPool', postNetworkPool)
            const localVarPath = `/api/networks/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postNetworkPool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {NetworkOVSDelete} networkOVSDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksUuidOvsApiNetworksOvsDelete: async (networkOVSDelete: NetworkOVSDelete, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkOVSDelete' is not null or undefined
            assertParamExists('postApiNetworksUuidOvsApiNetworksOvsDelete', 'networkOVSDelete', networkOVSDelete)
            const localVarPath = `/api/networks/ovs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkOVSDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {NetworkOVSAdd} [networkOVSAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksUuidOvsApiNetworksOvsPost: async (networkOVSAdd?: NetworkOVSAdd, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks/ovs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkOVSAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkDelete} [networkDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiNetworksDelete: async (networkDelete?: NetworkDelete, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkInsert} [networkInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiNetworksPost: async (networkInsert?: NetworkInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiNetworksApiNetworksPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkApi - functional programming interface
 * @export
 */
export const NetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNetworksApiNetworksGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetNetwork>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNetworksApiNetworksGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Networks Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNetworksPoolsApiNetworksPoolsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetNetworkPool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNetworksPoolsApiNetworksPoolsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Networks Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNetworksUuidApiNetworksUuidGet(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNetworksUuidApiNetworksUuidGet(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Networks Pools
         * @param {PatchNetworkPool} patchNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool: PatchNetworkPool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Networks Pools
         * @param {PostNetworkPool} postNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool: PostNetworkPool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {NetworkOVSDelete} networkOVSDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiNetworksUuidOvsApiNetworksOvsDelete(networkOVSDelete: NetworkOVSDelete, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiNetworksUuidOvsApiNetworksOvsDelete(networkOVSDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {NetworkOVSAdd} [networkOVSAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiNetworksUuidOvsApiNetworksOvsPost(networkOVSAdd?: NetworkOVSAdd, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiNetworksUuidOvsApiNetworksOvsPost(networkOVSAdd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkDelete} [networkDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStorageApiNetworksDelete(networkDelete?: NetworkDelete, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStorageApiNetworksDelete(networkDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkInsert} [networkInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStorageApiNetworksPost(networkInsert?: NetworkInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStorageApiNetworksPost(networkInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putApiNetworksApiNetworksPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putApiNetworksApiNetworksPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkApi - factory interface
 * @export
 */
export const NetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksApiNetworksGet(options?: any): AxiosPromise<Array<GetNetwork>> {
            return localVarFp.getApiNetworksApiNetworksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Networks Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksPoolsApiNetworksPoolsGet(options?: any): AxiosPromise<Array<GetNetworkPool>> {
            return localVarFp.getApiNetworksPoolsApiNetworksPoolsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Networks Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNetworksUuidApiNetworksUuidGet(uuid: string, options?: any): AxiosPromise<GetNetwork> {
            return localVarFp.getApiNetworksUuidApiNetworksUuidGet(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Networks Pools
         * @param {PatchNetworkPool} patchNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool: PatchNetworkPool, options?: any): AxiosPromise<any> {
            return localVarFp.patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Networks Pools
         * @param {PostNetworkPool} postNetworkPool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool: PostNetworkPool, options?: any): AxiosPromise<any> {
            return localVarFp.postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {NetworkOVSDelete} networkOVSDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksUuidOvsApiNetworksOvsDelete(networkOVSDelete: NetworkOVSDelete, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.postApiNetworksUuidOvsApiNetworksOvsDelete(networkOVSDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Networks Uuid Ovs
         * @param {NetworkOVSAdd} [networkOVSAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNetworksUuidOvsApiNetworksOvsPost(networkOVSAdd?: NetworkOVSAdd, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.postApiNetworksUuidOvsApiNetworksOvsPost(networkOVSAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkDelete} [networkDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiNetworksDelete(networkDelete?: NetworkDelete, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.postApiStorageApiNetworksDelete(networkDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {NetworkInsert} [networkInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiNetworksPost(networkInsert?: NetworkInsert, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.postApiStorageApiNetworksPost(networkInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Networks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiNetworksApiNetworksPut(options?: any): AxiosPromise<any> {
            return localVarFp.putApiNetworksApiNetworksPut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
export class NetworkApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public getApiNetworksApiNetworksGet(options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getApiNetworksApiNetworksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Networks Pools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public getApiNetworksPoolsApiNetworksPoolsGet(options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getApiNetworksPoolsApiNetworksPoolsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Networks Uuid
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public getApiNetworksUuidApiNetworksUuidGet(uuid: string, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getApiNetworksUuidApiNetworksUuidGet(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Networks Pools
     * @param {PatchNetworkPool} patchNetworkPool 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool: PatchNetworkPool, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).patchApiNetworksPoolsApiNetworksPoolsPatch(patchNetworkPool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Networks Pools
     * @param {PostNetworkPool} postNetworkPool 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool: PostNetworkPool, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).postApiNetworksPoolsApiNetworksPoolsPost(postNetworkPool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Networks Uuid Ovs
     * @param {NetworkOVSDelete} networkOVSDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public postApiNetworksUuidOvsApiNetworksOvsDelete(networkOVSDelete: NetworkOVSDelete, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).postApiNetworksUuidOvsApiNetworksOvsDelete(networkOVSDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Networks Uuid Ovs
     * @param {NetworkOVSAdd} [networkOVSAdd] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public postApiNetworksUuidOvsApiNetworksOvsPost(networkOVSAdd?: NetworkOVSAdd, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).postApiNetworksUuidOvsApiNetworksOvsPost(networkOVSAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storage
     * @param {NetworkDelete} [networkDelete] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public postApiStorageApiNetworksDelete(networkDelete?: NetworkDelete, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).postApiStorageApiNetworksDelete(networkDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storage
     * @param {NetworkInsert} [networkInsert] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public postApiStorageApiNetworksPost(networkInsert?: NetworkInsert, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).postApiStorageApiNetworksPost(networkInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public putApiNetworksApiNetworksPut(options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).putApiNetworksApiNetworksPut(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodeApi - axios parameter creator
 * @export
 */
export const NodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Api Nodes
         * @param {NodeDelete} [nodeDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiNodesApiNodesDelete: async (nodeDelete?: NodeDelete, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNodesApiNodesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Nodes Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNodesPoolsApiNodesPoolsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Node Role
         * @param {NodeRolePatch} nodeRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNodeRoleApiNodesRolePatch: async (nodeRolePatch: NodeRolePatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeRolePatch' is not null or undefined
            assertParamExists('patchApiNodeRoleApiNodesRolePatch', 'nodeRolePatch', nodeRolePatch)
            const localVarPath = `/api/nodes/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeRolePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Nodes Pools
         * @param {PatchNodePool} patchNodePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNodesPoolsApiNodesPoolsPatch: async (patchNodePool: PatchNodePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchNodePool' is not null or undefined
            assertParamExists('patchApiNodesPoolsApiNodesPoolsPatch', 'patchNodePool', patchNodePool)
            const localVarPath = `/api/nodes/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchNodePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Nodes
         * @param {NodeInsert} [nodeInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNodesApiNodesPost: async (nodeInsert?: NodeInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Nodes Pools
         * @param {NodeBase} nodeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNodesPoolsApiNodesPoolsPost: async (nodeBase: NodeBase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeBase' is not null or undefined
            assertParamExists('postApiNodesPoolsApiNodesPoolsPost', 'nodeBase', nodeBase)
            const localVarPath = `/api/nodes/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeApi - functional programming interface
 * @export
 */
export const NodeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Api Nodes
         * @param {NodeDelete} [nodeDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiNodesApiNodesDelete(nodeDelete?: NodeDelete, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiNodesApiNodesDelete(nodeDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNodesApiNodesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetNode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNodesApiNodesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Nodes Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiNodesPoolsApiNodesPoolsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiNodesPoolsApiNodesPoolsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Node Role
         * @param {NodeRolePatch} nodeRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiNodeRoleApiNodesRolePatch(nodeRolePatch: NodeRolePatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiNodeRoleApiNodesRolePatch(nodeRolePatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Nodes Pools
         * @param {PatchNodePool} patchNodePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiNodesPoolsApiNodesPoolsPatch(patchNodePool: PatchNodePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiNodesPoolsApiNodesPoolsPatch(patchNodePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Nodes
         * @param {NodeInsert} [nodeInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiNodesApiNodesPost(nodeInsert?: NodeInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiNodesApiNodesPost(nodeInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Nodes Pools
         * @param {NodeBase} nodeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiNodesPoolsApiNodesPoolsPost(nodeBase: NodeBase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiNodesPoolsApiNodesPoolsPost(nodeBase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodeApi - factory interface
 * @export
 */
export const NodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodeApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Api Nodes
         * @param {NodeDelete} [nodeDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiNodesApiNodesDelete(nodeDelete?: NodeDelete, options?: any): AxiosPromise<any> {
            return localVarFp.deleteApiNodesApiNodesDelete(nodeDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNodesApiNodesGet(options?: any): AxiosPromise<Array<GetNode>> {
            return localVarFp.getApiNodesApiNodesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Nodes Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiNodesPoolsApiNodesPoolsGet(options?: any): AxiosPromise<any> {
            return localVarFp.getApiNodesPoolsApiNodesPoolsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Node Role
         * @param {NodeRolePatch} nodeRolePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNodeRoleApiNodesRolePatch(nodeRolePatch: NodeRolePatch, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.patchApiNodeRoleApiNodesRolePatch(nodeRolePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Nodes Pools
         * @param {PatchNodePool} patchNodePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiNodesPoolsApiNodesPoolsPatch(patchNodePool: PatchNodePool, options?: any): AxiosPromise<any> {
            return localVarFp.patchApiNodesPoolsApiNodesPoolsPatch(patchNodePool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Nodes
         * @param {NodeInsert} [nodeInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNodesApiNodesPost(nodeInsert?: NodeInsert, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.postApiNodesApiNodesPost(nodeInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Nodes Pools
         * @param {NodeBase} nodeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiNodesPoolsApiNodesPoolsPost(nodeBase: NodeBase, options?: any): AxiosPromise<any> {
            return localVarFp.postApiNodesPoolsApiNodesPoolsPost(nodeBase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeApi - object-oriented interface
 * @export
 * @class NodeApi
 * @extends {BaseAPI}
 */
export class NodeApi extends BaseAPI {
    /**
     * 
     * @summary Delete Api Nodes
     * @param {NodeDelete} [nodeDelete] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public deleteApiNodesApiNodesDelete(nodeDelete?: NodeDelete, options?: AxiosRequestConfig) {
        return NodeApiFp(this.configuration).deleteApiNodesApiNodesDelete(nodeDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getApiNodesApiNodesGet(options?: AxiosRequestConfig) {
        return NodeApiFp(this.configuration).getApiNodesApiNodesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Nodes Pools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getApiNodesPoolsApiNodesPoolsGet(options?: AxiosRequestConfig) {
        return NodeApiFp(this.configuration).getApiNodesPoolsApiNodesPoolsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Node Role
     * @param {NodeRolePatch} nodeRolePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public patchApiNodeRoleApiNodesRolePatch(nodeRolePatch: NodeRolePatch, options?: AxiosRequestConfig) {
        return NodeApiFp(this.configuration).patchApiNodeRoleApiNodesRolePatch(nodeRolePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Nodes Pools
     * @param {PatchNodePool} patchNodePool 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public patchApiNodesPoolsApiNodesPoolsPatch(patchNodePool: PatchNodePool, options?: AxiosRequestConfig) {
        return NodeApiFp(this.configuration).patchApiNodesPoolsApiNodesPoolsPatch(patchNodePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Nodes
     * @param {NodeInsert} [nodeInsert] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public postApiNodesApiNodesPost(nodeInsert?: NodeInsert, options?: AxiosRequestConfig) {
        return NodeApiFp(this.configuration).postApiNodesApiNodesPost(nodeInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Nodes Pools
     * @param {NodeBase} nodeBase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public postApiNodesPoolsApiNodesPoolsPost(nodeBase: NodeBase, options?: AxiosRequestConfig) {
        return NodeApiFp(this.configuration).postApiNodesPoolsApiNodesPoolsPost(nodeBase, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Api Projects
         * @param {DeleteProject} deleteProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiProjectsApiProjectsDelete: async (deleteProject: DeleteProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteProject' is not null or undefined
            assertParamExists('deleteApiProjectsApiProjectsDelete', 'deleteProject', deleteProject)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Projects
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiProjectsApiProjectsGet: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Projects
         * @param {PostProject} postProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiProjectsApiProjectsPost: async (postProject: PostProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postProject' is not null or undefined
            assertParamExists('postApiProjectsApiProjectsPost', 'postProject', postProject)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Projects
         * @param {ProjectPatch} projectPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiProjectsApiProjectsPut: async (projectPatch: ProjectPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectPatch' is not null or undefined
            assertParamExists('putApiProjectsApiProjectsPut', 'projectPatch', projectPatch)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Api Projects
         * @param {DeleteProject} deleteProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiProjectsApiProjectsDelete(deleteProject: DeleteProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiProjectsApiProjectsDelete(deleteProject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Projects
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiProjectsApiProjectsGet(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiProjectsApiProjectsGet(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Projects
         * @param {PostProject} postProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiProjectsApiProjectsPost(postProject: PostProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiProjectsApiProjectsPost(postProject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Projects
         * @param {ProjectPatch} projectPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putApiProjectsApiProjectsPut(projectPatch: ProjectPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putApiProjectsApiProjectsPut(projectPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Api Projects
         * @param {DeleteProject} deleteProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiProjectsApiProjectsDelete(deleteProject: DeleteProject, options?: any): AxiosPromise<any> {
            return localVarFp.deleteApiProjectsApiProjectsDelete(deleteProject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Projects
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiProjectsApiProjectsGet(admin?: boolean, options?: any): AxiosPromise<Array<ProjectSelect>> {
            return localVarFp.getApiProjectsApiProjectsGet(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Projects
         * @param {PostProject} postProject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiProjectsApiProjectsPost(postProject: PostProject, options?: any): AxiosPromise<any> {
            return localVarFp.postApiProjectsApiProjectsPost(postProject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Projects
         * @param {ProjectPatch} projectPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiProjectsApiProjectsPut(projectPatch: ProjectPatch, options?: any): AxiosPromise<any> {
            return localVarFp.putApiProjectsApiProjectsPut(projectPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Delete Api Projects
     * @param {DeleteProject} deleteProject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public deleteApiProjectsApiProjectsDelete(deleteProject: DeleteProject, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).deleteApiProjectsApiProjectsDelete(deleteProject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Projects
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getApiProjectsApiProjectsGet(admin?: boolean, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).getApiProjectsApiProjectsGet(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Projects
     * @param {PostProject} postProject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public postApiProjectsApiProjectsPost(postProject: PostProject, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).postApiProjectsApiProjectsPost(postProject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Projects
     * @param {ProjectPatch} projectPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public putApiProjectsApiProjectsPut(projectPatch: ProjectPatch, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).putApiProjectsApiProjectsPut(projectPatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Api Storages
         * @param {StorageDelete} [storageDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiStoragesApiStoragesDelete: async (storageDelete?: StorageDelete, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Images
         * @param {string} [nodeName] 
         * @param {string} [poolUuid] 
         * @param {string} [name] 
         * @param {string} [rool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiImagesApiImagesGet: async (nodeName?: string, poolUuid?: string, name?: string, rool?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (nodeName !== undefined) {
                localVarQueryParameter['node_name'] = nodeName;
            }

            if (poolUuid !== undefined) {
                localVarQueryParameter['pool_uuid'] = poolUuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (rool !== undefined) {
                localVarQueryParameter['rool'] = rool;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesApiStoragesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Storages Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesPoolsApiStoragesPoolsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Images
         * @param {PatchImageFlavor} patchImageFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiImagesApiImagesPatch: async (patchImageFlavor: PatchImageFlavor, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchImageFlavor' is not null or undefined
            assertParamExists('patchApiImagesApiImagesPatch', 'patchImageFlavor', patchImageFlavor)
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchImageFlavor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageMetadataPatch} [storageMetadataPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiStoragesPatch: async (storageMetadataPatch?: StorageMetadataPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageMetadataPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageInsert} [storageInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiStoragesPost: async (storageInsert?: StorageInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PatchStoragePool} patchStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStoragesPoolsApiStoragesPoolsPatch: async (patchStoragePool: PatchStoragePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchStoragePool' is not null or undefined
            assertParamExists('postApiStoragesPoolsApiStoragesPoolsPatch', 'patchStoragePool', patchStoragePool)
            const localVarPath = `/api/storages/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchStoragePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PostStoragePool} postStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStoragesPoolsApiStoragesPoolsPost: async (postStoragePool: PostStoragePool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postStoragePool' is not null or undefined
            assertParamExists('postApiStoragesPoolsApiStoragesPoolsPost', 'postStoragePool', postStoragePool)
            const localVarPath = `/api/storages/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postStoragePool, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiImagesApiImagesPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put Api Images Scp
         * @param {ImageSCP} [imageSCP] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiImagesScpApiImagesScpPut: async (imageSCP?: ImageSCP, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images/scp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageSCP, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Api Storages
         * @param {StorageDelete} [storageDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiStoragesApiStoragesDelete(storageDelete?: StorageDelete, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiStoragesApiStoragesDelete(storageDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Images
         * @param {string} [nodeName] 
         * @param {string} [poolUuid] 
         * @param {string} [name] 
         * @param {string} [rool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiImagesApiImagesGet(nodeName?: string, poolUuid?: string, name?: string, rool?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiImagesApiImagesGet(nodeName, poolUuid, name, rool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiStoragesApiStoragesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiStoragesApiStoragesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Storages Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiStoragesPoolsApiStoragesPoolsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetStoragePool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiStoragesPoolsApiStoragesPoolsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Images
         * @param {PatchImageFlavor} patchImageFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiImagesApiImagesPatch(patchImageFlavor: PatchImageFlavor, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiImagesApiImagesPatch(patchImageFlavor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageMetadataPatch} [storageMetadataPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStorageApiStoragesPatch(storageMetadataPatch?: StorageMetadataPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStorageApiStoragesPatch(storageMetadataPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageInsert} [storageInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStorageApiStoragesPost(storageInsert?: StorageInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStorageApiStoragesPost(storageInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PatchStoragePool} patchStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool: PatchStoragePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PostStoragePool} postStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool: PostStoragePool, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putApiImagesApiImagesPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putApiImagesApiImagesPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put Api Images Scp
         * @param {ImageSCP} [imageSCP] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putApiImagesScpApiImagesScpPut(imageSCP?: ImageSCP, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putApiImagesScpApiImagesScpPut(imageSCP, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Api Storages
         * @param {StorageDelete} [storageDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiStoragesApiStoragesDelete(storageDelete?: StorageDelete, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.deleteApiStoragesApiStoragesDelete(storageDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Images
         * @param {string} [nodeName] 
         * @param {string} [poolUuid] 
         * @param {string} [name] 
         * @param {string} [rool] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiImagesApiImagesGet(nodeName?: string, poolUuid?: string, name?: string, rool?: string, options?: any): AxiosPromise<Array<ImageSelect>> {
            return localVarFp.getApiImagesApiImagesGet(nodeName, poolUuid, name, rool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesApiStoragesGet(options?: any): AxiosPromise<Array<StorageSelect>> {
            return localVarFp.getApiStoragesApiStoragesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Storages Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStoragesPoolsApiStoragesPoolsGet(options?: any): AxiosPromise<Array<GetStoragePool>> {
            return localVarFp.getApiStoragesPoolsApiStoragesPoolsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Images
         * @param {PatchImageFlavor} patchImageFlavor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiImagesApiImagesPatch(patchImageFlavor: PatchImageFlavor, options?: any): AxiosPromise<any> {
            return localVarFp.patchApiImagesApiImagesPatch(patchImageFlavor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageMetadataPatch} [storageMetadataPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiStoragesPatch(storageMetadataPatch?: StorageMetadataPatch, options?: any): AxiosPromise<any> {
            return localVarFp.postApiStorageApiStoragesPatch(storageMetadataPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storage
         * @param {StorageInsert} [storageInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStorageApiStoragesPost(storageInsert?: StorageInsert, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.postApiStorageApiStoragesPost(storageInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PatchStoragePool} patchStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool: PatchStoragePool, options?: any): AxiosPromise<any> {
            return localVarFp.postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Storages Pools
         * @param {PostStoragePool} postStoragePool 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool: PostStoragePool, options?: any): AxiosPromise<any> {
            return localVarFp.postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiImagesApiImagesPut(options?: any): AxiosPromise<any> {
            return localVarFp.putApiImagesApiImagesPut(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put Api Images Scp
         * @param {ImageSCP} [imageSCP] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApiImagesScpApiImagesScpPut(imageSCP?: ImageSCP, options?: any): AxiosPromise<any> {
            return localVarFp.putApiImagesScpApiImagesScpPut(imageSCP, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
    /**
     * 
     * @summary Delete Api Storages
     * @param {StorageDelete} [storageDelete] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public deleteApiStoragesApiStoragesDelete(storageDelete?: StorageDelete, options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).deleteApiStoragesApiStoragesDelete(storageDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Images
     * @param {string} [nodeName] 
     * @param {string} [poolUuid] 
     * @param {string} [name] 
     * @param {string} [rool] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public getApiImagesApiImagesGet(nodeName?: string, poolUuid?: string, name?: string, rool?: string, options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).getApiImagesApiImagesGet(nodeName, poolUuid, name, rool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Storages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public getApiStoragesApiStoragesGet(options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).getApiStoragesApiStoragesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Storages Pools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public getApiStoragesPoolsApiStoragesPoolsGet(options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).getApiStoragesPoolsApiStoragesPoolsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Images
     * @param {PatchImageFlavor} patchImageFlavor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public patchApiImagesApiImagesPatch(patchImageFlavor: PatchImageFlavor, options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).patchApiImagesApiImagesPatch(patchImageFlavor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storage
     * @param {StorageMetadataPatch} [storageMetadataPatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public postApiStorageApiStoragesPatch(storageMetadataPatch?: StorageMetadataPatch, options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).postApiStorageApiStoragesPatch(storageMetadataPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storage
     * @param {StorageInsert} [storageInsert] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public postApiStorageApiStoragesPost(storageInsert?: StorageInsert, options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).postApiStorageApiStoragesPost(storageInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storages Pools
     * @param {PatchStoragePool} patchStoragePool 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool: PatchStoragePool, options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).postApiStoragesPoolsApiStoragesPoolsPatch(patchStoragePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Storages Pools
     * @param {PostStoragePool} postStoragePool 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool: PostStoragePool, options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).postApiStoragesPoolsApiStoragesPoolsPost(postStoragePool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public putApiImagesApiImagesPut(options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).putApiImagesApiImagesPut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put Api Images Scp
     * @param {ImageSCP} [imageSCP] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public putApiImagesScpApiImagesScpPut(imageSCP?: ImageSCP, options?: AxiosRequestConfig) {
        return StorageApiFp(this.configuration).putApiImagesScpApiImagesScpPut(imageSCP, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksApiTasksDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tasks
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksApiTasksGet: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tasks Incomplete
         * @param {string} [updateHash] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIncompleteApiTasksIncompleteGet: async (updateHash?: string, admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/incomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (updateHash !== undefined) {
                localVarQueryParameter['update_hash'] = updateHash;
            }

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTasksApiTasksDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTasksApiTasksDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tasks
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasksApiTasksGet(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSelect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasksApiTasksGet(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Tasks Incomplete
         * @param {string} [updateHash] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasksIncompleteApiTasksIncompleteGet(updateHash?: string, admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasksIncompleteApiTasksIncompleteGet(updateHash, admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTasksApiTasksDelete(options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.deleteTasksApiTasksDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tasks
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksApiTasksGet(admin?: boolean, options?: any): AxiosPromise<Array<TaskSelect>> {
            return localVarFp.getTasksApiTasksGet(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tasks Incomplete
         * @param {string} [updateHash] 
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksIncompleteApiTasksIncompleteGet(updateHash?: string, admin?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.getTasksIncompleteApiTasksIncompleteGet(updateHash, admin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary Delete Tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTasksApiTasksDelete(options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).deleteTasksApiTasksDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tasks
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksApiTasksGet(admin?: boolean, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTasksApiTasksGet(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tasks Incomplete
     * @param {string} [updateHash] 
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasksIncompleteApiTasksIncompleteGet(updateHash?: string, admin?: boolean, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTasksIncompleteApiTasksIncompleteGet(updateHash, admin, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TicketsApi - axios parameter creator
 * @export
 */
export const TicketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Tickets
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTicketsApiTicketsGet: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Tickets
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTicketsApiTicketsIssuancesGet: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tickets/issuances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Issuances
         * @param {PostIssuance} postIssuance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiIssuancesApiTicketsIssuancesPost: async (postIssuance: PostIssuance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postIssuance' is not null or undefined
            assertParamExists('postApiIssuancesApiTicketsIssuancesPost', 'postIssuance', postIssuance)
            const localVarPath = `/api/tickets/issuances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postIssuance, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Tickets
         * @param {PostTicket} postTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiTicketsApiTicketsPost: async (postTicket: PostTicket, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTicket' is not null or undefined
            assertParamExists('postApiTicketsApiTicketsPost', 'postTicket', postTicket)
            const localVarPath = `/api/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTicket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketsApi - functional programming interface
 * @export
 */
export const TicketsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Tickets
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiTicketsApiTicketsGet(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTicket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiTicketsApiTicketsGet(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Tickets
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiTicketsApiTicketsIssuancesGet(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetIssuance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiTicketsApiTicketsIssuancesGet(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Issuances
         * @param {PostIssuance} postIssuance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiIssuancesApiTicketsIssuancesPost(postIssuance: PostIssuance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiIssuancesApiTicketsIssuancesPost(postIssuance, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Tickets
         * @param {PostTicket} postTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiTicketsApiTicketsPost(postTicket: PostTicket, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiTicketsApiTicketsPost(postTicket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TicketsApi - factory interface
 * @export
 */
export const TicketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Tickets
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTicketsApiTicketsGet(admin?: boolean, options?: any): AxiosPromise<Array<GetTicket>> {
            return localVarFp.getApiTicketsApiTicketsGet(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Tickets
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTicketsApiTicketsIssuancesGet(admin?: boolean, options?: any): AxiosPromise<Array<GetIssuance>> {
            return localVarFp.getApiTicketsApiTicketsIssuancesGet(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Issuances
         * @param {PostIssuance} postIssuance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiIssuancesApiTicketsIssuancesPost(postIssuance: PostIssuance, options?: any): AxiosPromise<any> {
            return localVarFp.postApiIssuancesApiTicketsIssuancesPost(postIssuance, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Tickets
         * @param {PostTicket} postTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiTicketsApiTicketsPost(postTicket: PostTicket, options?: any): AxiosPromise<any> {
            return localVarFp.postApiTicketsApiTicketsPost(postTicket, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketsApi - object-oriented interface
 * @export
 * @class TicketsApi
 * @extends {BaseAPI}
 */
export class TicketsApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Tickets
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getApiTicketsApiTicketsGet(admin?: boolean, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getApiTicketsApiTicketsGet(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Tickets
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public getApiTicketsApiTicketsIssuancesGet(admin?: boolean, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).getApiTicketsApiTicketsIssuancesGet(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Issuances
     * @param {PostIssuance} postIssuance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public postApiIssuancesApiTicketsIssuancesPost(postIssuance: PostIssuance, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).postApiIssuancesApiTicketsIssuancesPost(postIssuance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Tickets
     * @param {PostTicket} postTicket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsApi
     */
    public postApiTicketsApiTicketsPost(postTicket: PostTicket, options?: AxiosRequestConfig) {
        return TicketsApiFp(this.configuration).postApiTicketsApiTicketsPost(postTicket, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiUsersApiUsersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiUsersApiUsersGet_1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Users
         * @param {UserInsert} userInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiUsersApiUsersPost: async (userInsert: UserInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInsert' is not null or undefined
            assertParamExists('postApiUsersApiUsersPost', 'userInsert', userInsert)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Users
         * @param {UserInsert} userInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiUsersApiUsersPost_2: async (userInsert: UserInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInsert' is not null or undefined
            assertParamExists('postApiUsersApiUsersPost_2', 'userInsert', userInsert)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersMeApiUsersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersMeApiUsersMeGet_3: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiUsersApiUsersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiUsersApiUsersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiUsersApiUsersGet_1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiUsersApiUsersGet_1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Users
         * @param {UserInsert} userInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiUsersApiUsersPost(userInsert: UserInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiUsersApiUsersPost(userInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Users
         * @param {UserInsert} userInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiUsersApiUsersPost_2(userInsert: UserInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiUsersApiUsersPost_2(userInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsersMeApiUsersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsersMeApiUsersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsersMeApiUsersMeGet_3(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsersMeApiUsersMeGet_3(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiUsersApiUsersGet(options?: any): AxiosPromise<any> {
            return localVarFp.getApiUsersApiUsersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiUsersApiUsersGet_1(options?: any): AxiosPromise<any> {
            return localVarFp.getApiUsersApiUsersGet_1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Users
         * @param {UserInsert} userInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiUsersApiUsersPost(userInsert: UserInsert, options?: any): AxiosPromise<any> {
            return localVarFp.postApiUsersApiUsersPost(userInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Users
         * @param {UserInsert} userInsert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiUsersApiUsersPost_2(userInsert: UserInsert, options?: any): AxiosPromise<any> {
            return localVarFp.postApiUsersApiUsersPost_2(userInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersMeApiUsersMeGet(options?: any): AxiosPromise<any> {
            return localVarFp.readUsersMeApiUsersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read Users Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersMeApiUsersMeGet_3(options?: any): AxiosPromise<any> {
            return localVarFp.readUsersMeApiUsersMeGet_3(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Get Api Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getApiUsersApiUsersGet(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getApiUsersApiUsersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getApiUsersApiUsersGet_1(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getApiUsersApiUsersGet_1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Users
     * @param {UserInsert} userInsert 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postApiUsersApiUsersPost(userInsert: UserInsert, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).postApiUsersApiUsersPost(userInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Users
     * @param {UserInsert} userInsert 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postApiUsersApiUsersPost_2(userInsert: UserInsert, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).postApiUsersApiUsersPost_2(userInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Users Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public readUsersMeApiUsersMeGet(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).readUsersMeApiUsersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read Users Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public readUsersMeApiUsersMeGet_3(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).readUsersMeApiUsersMeGet_3(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VmsApi - axios parameter creator
 * @export
 */
export const VmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Api Domains
         * @param {DomainDelete} [domainDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiDomainsApiVmsDelete: async (domainDelete?: DomainDelete, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainApiVmsGet: async (admin?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainApiVmsVncTokenGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getApiDomainApiVmsVncTokenGet', 'token', token)
            const localVarPath = `/api/vms/vnc/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Api Domain Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainUuidApiVmsUuidGet: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getApiDomainUuidApiVmsUuidGet', 'uuid', uuid)
            const localVarPath = `/api/vms/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Domains
         * @param {DomainPatch} [domainPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiDomainsApiVmsPatch: async (domainPatch?: DomainPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Api Vm Network
         * @param {DomainNetworkChange} [domainNetworkChange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiVmNetworkApiVmsNetworkPatch: async (domainNetworkChange?: DomainNetworkChange, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vms/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainNetworkChange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Path Vms Core
         * @param {DomainPatchCore} domainPatchCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathVmsCoreApiVmsCorePatch: async (domainPatchCore: DomainPatchCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainPatchCore' is not null or undefined
            assertParamExists('pathVmsCoreApiVmsCorePatch', 'domainPatchCore', domainPatchCore)
            const localVarPath = `/api/vms/core`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainPatchCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Path Vms Name
         * @param {DomainPatchName} domainPatchName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathVmsNameApiVmsNamePatch: async (domainPatchName: DomainPatchName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainPatchName' is not null or undefined
            assertParamExists('pathVmsNameApiVmsNamePatch', 'domainPatchName', domainPatchName)
            const localVarPath = `/api/vms/name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainPatchName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Path Vms Project
         * @param {DomainProjectPatch} domainProjectPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathVmsProjectApiVmsProjectPatch: async (domainProjectPatch: DomainProjectPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainProjectPatch' is not null or undefined
            assertParamExists('pathVmsProjectApiVmsProjectPatch', 'domainProjectPatch', domainProjectPatch)
            const localVarPath = `/api/vms/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainProjectPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Path Vms User
         * @param {DomainPatchUser} domainPatchUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathVmsUserApiVmsUserPatch: async (domainPatchUser: DomainPatchUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainPatchUser' is not null or undefined
            assertParamExists('pathVmsUserApiVmsUserPatch', 'domainPatchUser', domainPatchUser)
            const localVarPath = `/api/vms/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainPatchUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {DomainInsert} [domainInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiVmsApiVmsPost: async (domainInsert?: DomainInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {PostDomainTicket} postDomainTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiVmsApiVmsTicketPost: async (postDomainTicket: PostDomainTicket, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postDomainTicket' is not null or undefined
            assertParamExists('postApiVmsApiVmsTicketPost', 'postDomainTicket', postDomainTicket)
            const localVarPath = `/api/vms/ticket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postDomainTicket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish Task To Update Vm List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishTaskToUpdateVmListApiVmsPut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VmsApi - functional programming interface
 * @export
 */
export const VmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Api Domains
         * @param {DomainDelete} [domainDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiDomainsApiVmsDelete(domainDelete?: DomainDelete, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiDomainsApiVmsDelete(domainDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiDomainApiVmsGet(admin?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetDomain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiDomainApiVmsGet(admin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiDomainApiVmsVncTokenGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiDomainApiVmsVncTokenGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Api Domain Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiDomainUuidApiVmsUuidGet(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiDomainUuidApiVmsUuidGet(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Domains
         * @param {DomainPatch} [domainPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiDomainsApiVmsPatch(domainPatch?: DomainPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiDomainsApiVmsPatch(domainPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Api Vm Network
         * @param {DomainNetworkChange} [domainNetworkChange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchApiVmNetworkApiVmsNetworkPatch(domainNetworkChange?: DomainNetworkChange, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchApiVmNetworkApiVmsNetworkPatch(domainNetworkChange, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Path Vms Core
         * @param {DomainPatchCore} domainPatchCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pathVmsCoreApiVmsCorePatch(domainPatchCore: DomainPatchCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pathVmsCoreApiVmsCorePatch(domainPatchCore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Path Vms Name
         * @param {DomainPatchName} domainPatchName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pathVmsNameApiVmsNamePatch(domainPatchName: DomainPatchName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pathVmsNameApiVmsNamePatch(domainPatchName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Path Vms Project
         * @param {DomainProjectPatch} domainProjectPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pathVmsProjectApiVmsProjectPatch(domainProjectPatch: DomainProjectPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pathVmsProjectApiVmsProjectPatch(domainProjectPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Path Vms User
         * @param {DomainPatchUser} domainPatchUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pathVmsUserApiVmsUserPatch(domainPatchUser: DomainPatchUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pathVmsUserApiVmsUserPatch(domainPatchUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {DomainInsert} [domainInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiVmsApiVmsPost(domainInsert?: DomainInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiVmsApiVmsPost(domainInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {PostDomainTicket} postDomainTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApiVmsApiVmsTicketPost(postDomainTicket: PostDomainTicket, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApiVmsApiVmsTicketPost(postDomainTicket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish Task To Update Vm List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishTaskToUpdateVmListApiVmsPut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSelect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishTaskToUpdateVmListApiVmsPut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VmsApi - factory interface
 * @export
 */
export const VmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VmsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Api Domains
         * @param {DomainDelete} [domainDelete] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiDomainsApiVmsDelete(domainDelete?: DomainDelete, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.deleteApiDomainsApiVmsDelete(domainDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {boolean} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainApiVmsGet(admin?: boolean, options?: any): AxiosPromise<Array<GetDomain>> {
            return localVarFp.getApiDomainApiVmsGet(admin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Domain
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainApiVmsVncTokenGet(token: string, options?: any): AxiosPromise<any> {
            return localVarFp.getApiDomainApiVmsVncTokenGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Api Domain Uuid
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiDomainUuidApiVmsUuidGet(uuid: string, options?: any): AxiosPromise<GetDomainDetail> {
            return localVarFp.getApiDomainUuidApiVmsUuidGet(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Domains
         * @param {DomainPatch} [domainPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiDomainsApiVmsPatch(domainPatch?: DomainPatch, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.patchApiDomainsApiVmsPatch(domainPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Api Vm Network
         * @param {DomainNetworkChange} [domainNetworkChange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchApiVmNetworkApiVmsNetworkPatch(domainNetworkChange?: DomainNetworkChange, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.patchApiVmNetworkApiVmsNetworkPatch(domainNetworkChange, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Path Vms Core
         * @param {DomainPatchCore} domainPatchCore 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathVmsCoreApiVmsCorePatch(domainPatchCore: DomainPatchCore, options?: any): AxiosPromise<any> {
            return localVarFp.pathVmsCoreApiVmsCorePatch(domainPatchCore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Path Vms Name
         * @param {DomainPatchName} domainPatchName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathVmsNameApiVmsNamePatch(domainPatchName: DomainPatchName, options?: any): AxiosPromise<any> {
            return localVarFp.pathVmsNameApiVmsNamePatch(domainPatchName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Path Vms Project
         * @param {DomainProjectPatch} domainProjectPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathVmsProjectApiVmsProjectPatch(domainProjectPatch: DomainProjectPatch, options?: any): AxiosPromise<any> {
            return localVarFp.pathVmsProjectApiVmsProjectPatch(domainProjectPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Path Vms User
         * @param {DomainPatchUser} domainPatchUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pathVmsUserApiVmsUserPatch(domainPatchUser: DomainPatchUser, options?: any): AxiosPromise<any> {
            return localVarFp.pathVmsUserApiVmsUserPatch(domainPatchUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {DomainInsert} [domainInsert] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiVmsApiVmsPost(domainInsert?: DomainInsert, options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.postApiVmsApiVmsPost(domainInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post Api Vms
         * @param {PostDomainTicket} postDomainTicket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApiVmsApiVmsTicketPost(postDomainTicket: PostDomainTicket, options?: any): AxiosPromise<any> {
            return localVarFp.postApiVmsApiVmsTicketPost(postDomainTicket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish Task To Update Vm List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishTaskToUpdateVmListApiVmsPut(options?: any): AxiosPromise<TaskSelect> {
            return localVarFp.publishTaskToUpdateVmListApiVmsPut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VmsApi - object-oriented interface
 * @export
 * @class VmsApi
 * @extends {BaseAPI}
 */
export class VmsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Api Domains
     * @param {DomainDelete} [domainDelete] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public deleteApiDomainsApiVmsDelete(domainDelete?: DomainDelete, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).deleteApiDomainsApiVmsDelete(domainDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Domain
     * @param {boolean} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public getApiDomainApiVmsGet(admin?: boolean, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).getApiDomainApiVmsGet(admin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Domain
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public getApiDomainApiVmsVncTokenGet(token: string, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).getApiDomainApiVmsVncTokenGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Api Domain Uuid
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public getApiDomainUuidApiVmsUuidGet(uuid: string, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).getApiDomainUuidApiVmsUuidGet(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Domains
     * @param {DomainPatch} [domainPatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public patchApiDomainsApiVmsPatch(domainPatch?: DomainPatch, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).patchApiDomainsApiVmsPatch(domainPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Api Vm Network
     * @param {DomainNetworkChange} [domainNetworkChange] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public patchApiVmNetworkApiVmsNetworkPatch(domainNetworkChange?: DomainNetworkChange, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).patchApiVmNetworkApiVmsNetworkPatch(domainNetworkChange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Path Vms Core
     * @param {DomainPatchCore} domainPatchCore 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public pathVmsCoreApiVmsCorePatch(domainPatchCore: DomainPatchCore, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).pathVmsCoreApiVmsCorePatch(domainPatchCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Path Vms Name
     * @param {DomainPatchName} domainPatchName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public pathVmsNameApiVmsNamePatch(domainPatchName: DomainPatchName, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).pathVmsNameApiVmsNamePatch(domainPatchName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Path Vms Project
     * @param {DomainProjectPatch} domainProjectPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public pathVmsProjectApiVmsProjectPatch(domainProjectPatch: DomainProjectPatch, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).pathVmsProjectApiVmsProjectPatch(domainProjectPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Path Vms User
     * @param {DomainPatchUser} domainPatchUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public pathVmsUserApiVmsUserPatch(domainPatchUser: DomainPatchUser, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).pathVmsUserApiVmsUserPatch(domainPatchUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Vms
     * @param {DomainInsert} [domainInsert] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public postApiVmsApiVmsPost(domainInsert?: DomainInsert, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).postApiVmsApiVmsPost(domainInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post Api Vms
     * @param {PostDomainTicket} postDomainTicket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public postApiVmsApiVmsTicketPost(postDomainTicket: PostDomainTicket, options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).postApiVmsApiVmsTicketPost(postDomainTicket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish Task To Update Vm List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmsApi
     */
    public publishTaskToUpdateVmListApiVmsPut(options?: AxiosRequestConfig) {
        return VmsApiFp(this.configuration).publishTaskToUpdateVmListApiVmsPut(options).then((request) => request(this.axios, this.basePath));
    }
}


